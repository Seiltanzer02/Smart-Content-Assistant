from fastapi import FastAPI, HTTPException, UploadFile, File, Query, Request, Form, Depends, Body
import uvicorn
import os
from pydantic import BaseModel, Field, Json
from fastapi import HTTPException
import logging
import asyncio  # ��� ����������� �������� � sleep
from fastapi.middleware.cors import CORSMiddleware
from telethon import TelegramClient
from telethon.errors import ChannelInvalidError, ChannelPrivateError, UsernameNotOccupiedError
from dotenv import load_dotenv
import httpx # ��� ����������� HTTP ��������
from collections import Counter
import re # ��� ������� ������
from openai import AsyncOpenAI, OpenAIError # ��������� OpenAI
import json # ��� �������� �������������� JSON ������
from typing import List, Optional, Dict, Any, Tuple, Union
from telethon.tl.functions.channels import GetFullChannelRequest
from telethon.tl.types import Message
import random # <--- ��������� ������ random
from supabase import create_client, Client, AClient # <--- ����������� create_client, Client, AClient
from postgrest.exceptions import APIError # <--- ����������� �� POSTGREST
from telethon.sessions import StringSession # ���� ���������� ������ ������
from telethon.errors import SessionPasswordNeededError, FloodWaitError, PhoneNumberInvalidError, AuthKeyError, ApiIdInvalidError
import uuid # ��� ��������� ���������� ���� ������
import mimetypes # ��� ����������� ���� �����
from telethon.errors import RPCError
import getpass # ��� ��������� ������
from fastapi.responses import FileResponse, Response # ��������� Response
from fastapi.staticfiles import StaticFiles
import time # ��������� ������ time ��� ������ � ��������
import requests
from bs4 import BeautifulSoup
import telethon
import aiohttp
from telegram_utils import get_telegram_posts, get_mock_telegram_posts
import move_temp_files
from datetime import datetime
import traceback
# ������� �������������� ������� psycopg2
# import psycopg2 # ��������� ������ ��� ������� ����������� (���� �����)
# from psycopg2 import sql # ��� ���������� ������� ���� ������/�������
import shutil # ��������� ������ shutil
import base64 # ��������� ������ base64
from starlette.requests import Request
from starlette.responses import Response
from starlette.middleware.base import BaseHTTPMiddleware

#    
from services.subscription_service import SubscriptionService, FREE_ANALYSIS_LIMIT, FREE_POST_LIMIT, SUBSCRIPTION_PRICE, SUBSCRIPTION_DURATION_MONTHS

# --- ��������� ������� ��� Unsplash --- 
# from pyunsplash import PyUnsplash # <-- ������� ������������ ������
from unsplash import Api as UnsplashApi # <-- ����������� �� ����������� ������
from unsplash import Auth as UnsplashAuth # <-- ����������� �� ����������� ������
# ---------------------------------------

# --- ���������� ������������ � ������ --- 
# === ��������: ������� ����������� �� DEBUG ===
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s')
# === ����� ��������� ===
logger = logging.getLogger(__name__)
# --- ����� ����������� --- 

# --- �������� ���������� ��������� (��������� ��� ������ ������) --- 
# ������� ���������� print ��� load_dotenv
dotenv_loaded = load_dotenv(override=True)

# ���������� �� Render ����� ��������� ��� .env ������
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
TELEGRAM_API_ID = os.getenv("TELEGRAM_API_ID")
TELEGRAM_API_HASH = os.getenv("TELEGRAM_API_HASH")
UNSPLASH_ACCESS_KEY = os.getenv("UNSPLASH_ACCESS_KEY")
PEXELS_API_KEY = os.getenv("PEXELS_API_KEY")
SUPABASE_URL = os.getenv("SUPABASE_URL") 
SUPABASE_ANON_KEY = os.getenv("SUPABASE_ANON_KEY") 

# --- ��������� (������� ��� ������ Telegram) --- 
SESSION_NAME = "telegram_session" # <-- ���������� ��� ����� ������
IMAGE_SEARCH_COUNT = 15 # ������� ����������� ����������� � Unsplash
IMAGE_RESULTS_COUNT = 5 # ������� ����������� ���������� ������������

# --- ��������� ���������� ��������� ��� ���������� ���������� --- 
missing_keys = []
if not OPENROUTER_API_KEY:
    logger.warning("���� OPENROUTER_API_KEY �� ������! ������� ������� �������� ����� ����������.")
    missing_keys.append("OPENROUTER_API_KEY")

if not TELEGRAM_API_ID or not TELEGRAM_API_HASH:
    logger.warning("TELEGRAM_API_ID ��� TELEGRAM_API_HASH �� �������! ������� ������ � Telegram API ����� ����������.")
    if not TELEGRAM_API_ID:
        missing_keys.append("TELEGRAM_API_ID")
    if not TELEGRAM_API_HASH:
        missing_keys.append("TELEGRAM_API_HASH")

if not UNSPLASH_ACCESS_KEY:
    logger.warning("���� UNSPLASH_ACCESS_KEY �� ������! ����� ����������� ����� Unsplash ����� ����������.")
    missing_keys.append("UNSPLASH_ACCESS_KEY")

if not SUPABASE_URL or not SUPABASE_ANON_KEY:
    logger.warning("SUPABASE_URL ��� SUPABASE_ANON_KEY �� �������! ������� ���������� ������ ����� ����������.")
    if not SUPABASE_URL:
        missing_keys.append("SUPABASE_URL")
    if not SUPABASE_ANON_KEY:
        missing_keys.append("SUPABASE_ANON_KEY")

# ����� ���������� � ��������� ���������� ���������
if missing_keys:
    logger.warning(f"����������� ��������� ���������� ���������: {', '.join(missing_keys)}")
    logger.warning("��������� ������� ���������� ����� ���� ����������.")
else:
    logger.info("��� ����������� ���������� ��������� �������.")

# --- ������������� Supabase client ---
logger.info("������������� Supabase...")
supabase_url = os.getenv("SUPABASE_URL")
supabase_key = os.getenv("SUPABASE_ANON_KEY")

if not supabase_url or not supabase_key:
    logger.warning("SUPABASE_URL ��� SUPABASE_ANON_KEY �� ������� � ���������.")
    supabase = None
else:
    try:
        # ������� ������ Supabase
        supabase = create_client(supabase_url, supabase_key)
        logger.info("Supabase ������� ���������������.")
        
        # ��������� ����������� ������
        try:
            # ������� �������� ������ �� ������� suggested_ideas ��� ��������
            supabase.table("suggested_ideas").select("id").limit(1).execute()
            logger.info("������� suggested_ideas ���������� � ��������.")
        except Exception as table_err:
            logger.warning(f"������� suggested_ideas ����������: {table_err}. ��������, �������� �� ���� ���������.")
    except Exception as e:
        logger.error(f"������ ��� ������������� Supabase: {e}")
        supabase = None
# ---------------------------------------

# --- ��������������� ������� ��� ������ SQL-�������� ����� API Supabase ---
async def _execute_sql_direct(sql_query: str) -> Dict[str, Any]:
    """��������� ������ SQL ������ ����� Supabase API."""
    supabase_url = os.getenv('SUPABASE_URL')
    supabase_key = os.getenv('SUPABASE_ANON_KEY')
    
    if not supabase_url or not supabase_key:
        logger.error("�� ������� ���������� ��������� SUPABASE_URL ��� SUPABASE_ANON_KEY ��� ������� SQL")
        return {"status_code": 500, "error": "Missing Supabase credentials"}
        
    url = f"{supabase_url}/rest/v1/rpc/exec_sql_array_json" # ���������� ���� RPC �������
    headers = {
        "apikey": supabase_key,
        "Authorization": f"Bearer {supabase_key}",
        "Content-Type": "application/json"
    }
    
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(url, json={"query": sql_query}, headers=headers)
        
        if response.status_code in [200, 204]:
            try:
                return {"status_code": response.status_code, "data": response.json()}
            except json.JSONDecodeError:
                # ��� 204 ������ ���� ����� �� ����
                return {"status_code": response.status_code, "data": None}
        else:
            logger.error(f"������ ��� ���������� ������� SQL �������: {response.status_code} - {response.text}")
            return {"status_code": response.status_code, "error": response.text}
            
    except httpx.RequestError as e:
        logger.error(f"������ HTTP ������� ��� ���������� ������� SQL: {e}")
        return {"status_code": 500, "error": str(e)}
    except Exception as e:
        logger.error(f"�������������� ������ ��� ���������� ������� SQL: {e}")
        return {"status_code": 500, "error": str(e)}
# -------------------------------------------------------------------

# --- ������������� FastAPI --- 
app = FastAPI(
    title="Smart Content Assistant API",
    description="API ��� ������� Telegram ������� � ��������� �������-������."
)

# ��������� CORS
origins = [
    "http://localhost", 
    "http://localhost:5173",
    "http://127.0.0.1:5173",
    "http://localhost:3000",
    "https://*.onrender.com",  # ��� Render
    "https://t.me",            # ��� Telegram
    "*"                        # �������� ��������� ���
]

# Класс для отключения кэширования на стороне сервера
class NoCacheMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        if "/subscription/" in request.url.path:
            response.headers["Cache-Control"] = "no-store, no-cache, must-revalidate, max-age=0"
            response.headers["Pragma"] = "no-cache"
            response.headers["Expires"] = "0"
        return response

app.add_middleware(NoCacheMiddleware)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

#      Telegram WebApp
class WebAppDataRequest(BaseModel):
    data: str  # JSON-   Telegram
    user: Dict[str, Any]  #  
    
    class Config:
        schema_extra = {
            "example": {
                "data": '{"type":"subscribe","tier":"premium_monthly","price":70}',
                "user": {"id": 123456789, "first_name": "John", "last_name": "Doe"}
            }
        }
        
# ����������� ������ ��� ������� �� �������� ��������
class CreateSubscriptionRequest(BaseModel):
    user_id: int
    payment_id: Optional[str] = None
    
# ����������� ������ ��� ������ � ������� ��������
class SubscriptionStatusResponse(BaseModel):
    has_subscription: bool
    analysis_count: int
    post_generation_count: int
    subscription_end_date: Optional[str] = None

# ---     ---
import os
from fastapi.staticfiles import StaticFiles

#     
static_folder = os.path.join(os.path.dirname(__file__), "static")

#      
SHOULD_MOUNT_STATIC = os.path.exists(static_folder)
#  , ,      SPA
SPA_ROUTES_CONFIGURED = False

if SHOULD_MOUNT_STATIC:
    logger.info(f"     : {static_folder} (  )")
else:
    logger.warning(f"    : {static_folder}")
    logger.warning("    .  API endpoints .")

class AnalyzeRequest(BaseModel):
    username: str

class AnalysisResult(BaseModel):
    themes: List[str]
    styles: List[str]
    analyzed_posts_sample: List[str]
    best_posting_time: str # 
    analyzed_posts_count: int
    
#     AnalyzeResponse
class AnalyzeResponse(BaseModel):
    themes: List[str]
    styles: List[str]
    analyzed_posts_sample: List[str] 
    best_posting_time: str
    analyzed_posts_count: int
    message: Optional[str] = None
    error: Optional[str] = None
    
# ---     ---
class PlanGenerationRequest(BaseModel):
    themes: List[str]
    styles: List[str]
    period_days: int = Field(7, gt=0, le=30) # 
    channel_name: str # 

#      (  )
class PlanItem(BaseModel):
    day: int # 
    topic_idea: str # 
    format_style: str # 

# ---     ---
class GeneratePostDetailsRequest(BaseModel):
    topic_idea: str = Field(..., description=" ")
    format_style: str = Field(..., description=" ")
    keywords: Optional[List[str]] = Field(None, description="( )  ( )  ( )") 
    post_samples: Optional[List[str]] = Field(None, description=" ")

# ---     ---
class FoundImage(BaseModel):
    id: str
    source: str # 
    preview_url: str # URL 
    regular_url: str # URL 
    description: Optional[str] = None
    author_name: Optional[str] = None
    author_url: Optional[str] = None

# ---     PostImage     ---
class PostImage(BaseModel):
    url: str
    id: Optional[str] = None
    preview_url: Optional[str] = None
    alt: Optional[str] = None
    author: Optional[str] = None # 
    author_url: Optional[str] = None
    source: Optional[str] = None

# ---     PostDetailsResponse     ---
class PostDetailsResponse(BaseModel):
    generated_text: str = Field(..., description=" ")
    found_images: List[FoundImage] = Field([], description=" ") 
    message: str = Field("", description=" ")
    channel_name: Optional[str] = Field(None, description=" ,  ")
    #     PostImage 
    selected_image_data: Optional[PostImage] = Field(None, description=" ")

# ---     PostData     ---
class PostData(BaseModel):
    target_date: str = Field(..., description="YYYY-MM-DD")
    topic_idea: str
    format_style: str
    final_text: str
    image_url: Optional[str] = Field(None, description="URL  ( )") # 
    images_ids: Optional[List[str]] = Field(None, description=" ") # 
    channel_name: Optional[str] = Field(None, description=" ,  ")
    # PostImage 
    selected_image_data: Optional[PostImage] = Field(None, description=" ")

# ---     SavedPostResponse     ---
class SavedPostResponse(PostData):
    id: str 
    #     PostData
    # created_at: str 
    # updated_at: str
    # image_url: Optional[str] = Field(None, description="URL  ( )")
    # images_ids: Optional[List[str]] = Field(None, description=" ")
    # channel_name: Optional[str] = Field(None, description=" ,  ")
    #      , 
    created_at: str = Field(..., description=" ")
    updated_at: str = Field(..., description=" ")

# ---     Telegram HTTP     ---
async def get_telegram_posts_via_http(username: str) -> List[str]:
    """     Telegram HTTP ."""
    try:
        url = f"https://t.me/s/{username}"
        logger.info(f"HTTP  @: {url}")
        
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.get(url)
            
            
        if response.status_code != 200:
            logger.warning(f"HTTP ������-��� ��� @{username}: {response.status_code}")
            return []
            
        # ���������� BeautifulSoup ��� �������� HTML
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # ���� ����� � �����������
        message_blocks = soup.select('div.tgme_widget_message_bubble')
        
        if not message_blocks:
            logger.warning(f"�� ������� ����� ��������� ��� @{username}")
            return []
            
        # ��������� ����� ���������
        posts = []
        for block in message_blocks:
            text_block = block.select_one('div.tgme_widget_message_text')
            if text_block and text_block.text.strip():
                posts.append(text_block.text.strip())
        
        logger.info(f"������� {len(posts)} ������ ����� HTTP ������� ��� @{username}")
        return posts
        
    except Exception as e:
        logger.error(f"������ ��� HTTP �������� ������ @{username}: {e}")
        raise

# --- ������� ��� ��������� �������� ������ ---
def get_sample_posts(channel_name: str) -> List[str]:
    """���������� ������ ������ ��� ������������ � ������, ���� �� ������� �������� �������� �����."""
    # ������� ������� ������
    generic_posts = [
        "������ ����, ��������� ����������! ������� �� ������� ������ ����, ������� �������� �������.",
        "������������ ��� ����� ����� ���������� �������. ���������� ���� ����������� � �������� �������.",
        "���������� ����: ������ �� ��, ��� ���������� ����������, ��� 90% �����...",
        "� ���� ����� �� �������� ����� ���������� ������� �� ����� �����������.",
        "�������� ����� ������: ��� ������� ��������� � ��� ��� ���� �������."
    ]
    
    # ����� �������� ����������� ������� ��� ������ �������
    tech_posts = [
        "����� iPhone ��� � �������. ������ ����������� � ����� �������������.",
        "����� ��������� ��������� � Android. ��� ��� ���� � ����� ������?",
        "�� � ��� ������� �� ����������� ����������������: �������� ����������� ��� �������������.",
        "����� ���� ���������������� ������� � 2024 ����? ����� ���������� ����������.",
        "����� ����������� ��� ���-����������, ������� ����� ����������� �������."
    ]
    
    business_posts = [
        "5 ���������, ������� ������� ������ ������� ����� �� ����� �������.",
        "��� ��������� ������������� � 2024 ����? ������ ���������.",
        "����-���������� ��� ������������: ��� ��� �������� � �� ��������.",
        "������ �����: ������� ������ � �������� �� ��������� �������.",
        "������� ������: ��� ��������� ������� ����������� � ���������� ������."
    ]
    
    # �������� ���������� ����� �������� � ����������� �� ����� ������
    channel_lower = channel_name.lower()
    if any(keyword in channel_lower for keyword in ["tech", "code", "programming", "dev", "it"]):
        return tech_posts
    elif any(keyword in channel_lower for keyword in ["business", "finance", "money", "startup"]):
        return business_posts
    else:
        return generic_posts

# --- ������� ��� ���������� ����������� ������� � ���� ������ ---
async def save_suggested_idea(idea_data: Dict[str, Any]) -> str:
    """��������� ������������ ���� � ���� ������."""
    try:
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            return "������: ������ Supabase �� ���������������"
        
        # �������������� ������ � ������������ �� ���������� ������� suggested_ideas
        idea_to_save = {
            "id": str(uuid.uuid4()),  # ���������� UUID
            "channel_name": idea_data.get("channel_name", ""),
            "user_id": idea_data.get("user_id"),
            "topic_idea": idea_data.get("topic_idea", ""),
            "format_style": idea_data.get("format_style", ""),
            "relative_day": idea_data.get("day", 0),
            "is_detailed": False  # ���������� ���� �� ��������������
        }
        
        # ���������� � Supabase
        result = supabase.table("suggested_ideas").insert(idea_to_save).execute()
        
        # �������� ����������
        if hasattr(result, 'data') and len(result.data) > 0:
            logger.info(f"������� ��������� ���� ��� ������ {idea_data.get('channel_name')}")
            return "success"
        else:
            logger.error(f"������ ��� ���������� ����: {result}")
            return "error"
            
    except Exception as e:
        logger.error(f"������ ��� ���������� ����: {e}")
        return f"������: {str(e)}"

# --- ������� ��� ������� �������� � ������� DeepSeek ---
async def analyze_content_with_deepseek(texts: List[str], api_key: str) -> Dict[str, List[str]]:
    """������ �������� � �������������� ������ DeepSeek ����� OpenRouter API."""
    
    # ��������� ������� API �����
    if not api_key:
        logger.warning("������ �������� � DeepSeek ����������: ����������� OPENROUTER_API_KEY")
        return {
            "themes": ["���� 1", "���� 2", "���� 3", "���� 4", "���� 5"],
            "styles": ["������ 1", "������ 2", "������ 3", "������ 4", "������ 5"]
        }
    
    # ���� ��� ������� ��� API �����, ���������� ������ ���������
    if not texts or not api_key:
        logger.error("����������� ������ ��� API ���� ��� �������")
        return {"themes": [], "styles": []}
    
    # ���������� ������ ��� �������
    combined_text = "\n\n".join([f"���� {i+1}: {text}" for i, text in enumerate(texts)])
    logger.info(f"������������ {len(texts)} ������� ��� ������� ����� DeepSeek")
    
    # �������������� �������
    system_prompt = """�� - �������� �������� ��� Telegram-�������. 
    �������� �������� ���� � ������� �������� ������. 
    ����� � JSON ������� � ������ "themes" � "styles", ��� ������ �������� ������ �����."""
    
    user_prompt = f"""������������� ��������� ����� � �������� �������� ���� � �������:
{combined_text}
������ 5-7 �������� ��� � 5-7 �������� ������. ������ JSON ������."""
    
    # ������ ������ � API
    analysis_result = {"themes": [], "styles": []}
    
    try:
        # �������������� ������
        client = AsyncOpenAI(
            base_url="https://openrouter.ai/api/v1",
            api_key=api_key
        )
        
        # ����������� ����� �� API
        response = await client.chat.completions.create(
            model="deepseek/deepseek-chat",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.1,
            max_tokens=600,
            timeout=60,
            extra_headers={
                "HTTP-Referer": "https://content-manager.onrender.com",
                "X-Title": "Smart Content Assistant"
            }
        )
        
        # �������� ����� ������
        analysis_text = response.choices[0].message.content.strip()
        logger.info(f"������� ����� �� DeepSeek: {analysis_text[:100]}...")
        
        # ��������� JSON �� ������
        json_match = re.search(r'(\{.*\})', analysis_text, re.DOTALL)
        if json_match:
            analysis_text = json_match.group(1)
        
        # ������ JSON
        analysis_json = json.loads(analysis_text)
        
        # ��������� ��������� JSON
        if "themes" in analysis_json and "styles" in analysis_json:
            analysis_result = analysis_json
        else:
            logger.warning(f"������������ ��������� JSON: {analysis_json}")
    
    except json.JSONDecodeError as e:
        # ���� �� ������� ���������� JSON, ���������� ���������� ���������
        logger.error(f"������ �������� JSON: {e}, �����: {analysis_text}")
        
        themes_match = re.findall(r'"themes":\s*\[(.*?)\]', analysis_text, re.DOTALL)
        if themes_match:
            theme_items = re.findall(r'"([^"]+)"', themes_match[0])
            analysis_result["themes"] = theme_items
        
        styles_match = re.findall(r'"styles":\s*\[(.*?)\]', analysis_text, re.DOTALL)
        if styles_match:
            style_items = re.findall(r'"([^"]+)"', styles_match[0])
            analysis_result["styles"] = style_items
    
    except Exception as e:
        # ������������ ����� ������ ������
        logger.error(f"������ ��� ������� �������� ����� DeepSeek: {e}")
    
    return analysis_result

@app.post("/analyze", response_model=AnalyzeResponse)
async def analyze_channel(
    request: Request, 
    req: AnalyzeRequest,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    """����������� Telegram �����"""
    startTime = time.time() # ��� ��������� ������� ����������
    
    # �������� ������������� ������������ �� ���������
    user_id_str = request.headers.get("x-telegram-user-id")
    if not user_id_str:
        raise HTTPException(status_code=401, detail="��������� �����������")
    
    try:
        user_id = int(user_id_str)
    except ValueError:
        raise HTTPException(status_code=400, detail="������������ ������������� ������������")
    
    # ���������, ����� �� ������������ ������������� ������
    can_analyze = await subscription_service.can_analyze_channel(user_id)
    if not can_analyze:
        raise HTTPException(
            status_code=403, 
            detail=f"��������� ����� ���������� �������� ({FREE_ANALYSIS_LIMIT}). ����������� ��������."
        )
    
    # Get username from request
    username = req.username
    
    # Remove @ if present
    if username.startswith('@'):
        username = username[1:]
    
    # ���������� Mock ���� ������ �� localhost ��� Telegram API
    is_mock = not TELEGRAM_API_ID or not TELEGRAM_API_HASH
    
    if is_mock:
        logger.warning("������������ MOCK ��� Telegram API (��� ������� � Telegram API)")
        
    try:
        logger.info(f"������ �� ������ ������: {username}")
        
        # ���������, ��� �� ����� ��� ���������������
        channel_data = None
        try:
            if supabase:
                # �������� ������������ ������ �� Supabase
                result = await _execute_sql_direct(
                    f"""
                    SELECT * FROM channel_analysis 
                    WHERE channel_name = '{username}' 
                    ORDER BY created_at DESC
                    LIMIT 1
                    """
                )
                
                if result.get("status_code") == 200 and result.get("data") and len(result["data"]) > 0:
                    channel_data = result["data"][0]
                    
                    # ���� ������ �� ������, ���������� ��
                    if (
                        channel_data and 
                        channel_data.get("themes") and 
                        channel_data.get("styles") and
                        len(channel_data.get("themes", [])) > 0 and 
                        len(channel_data.get("styles", [])) > 0
                    ):
                        logger.info(f"������ ������������ ������ ��� ������ {username}")
                        
                        # ����������� ����� �������� ������ AnalyzeResponse 
                        response = {
                            "themes": channel_data.get("themes", []),
                            "styles": channel_data.get("styles", []),
                            "analyzed_posts_sample": channel_data.get("analyzed_posts_sample", []),
                            "best_posting_time": channel_data.get("best_posting_time", ""),
                            "analyzed_posts_count": channel_data.get("analyzed_posts_count", 0),
                            "message": "������ ��������� �� ����"
                        }
                        return response
    except Exception as e:
            logger.error(f"������ ��� �������� ������������� �������: {e}")
            # ���������� ���������� � ������� ��������� ������
        
        # ���� ��������, ���� ��� ������������� ������� ��� �������� ������ ��� ��� ���������
        # �������� ��������� �����
        if is_mock:
            posts = get_mock_telegram_posts(username)
        else:
            posts = await get_telegram_posts(username)
        
        if not posts:
            raise HTTPException(
                status_code=404, 
                detail="�� ������� �������� ����� ��� �������. ��������� ������������ ����� ������."
            )
        
        # ���������� ������ ������ � ������ ������� ��� �������
        post_texts = [post["text"] for post in posts if post.get("text")]
        
        if not post_texts:
            raise HTTPException(
                status_code=404, 
                detail="�� ������� ��������� ������ ��� �������"
            )
        
        # ���������� LLM ��� ������� �������
        openai_response = await analyze_content_with_deepseek(post_texts[:20], OPENROUTER_API_KEY)
        
        if not openai_response:
            raise HTTPException(
                status_code=500, 
                detail="������ ��� ������� �������� � ������� AI"
            )
        
        themes = openai_response.get("themes", [])
        styles = openai_response.get("styles", [])
        
        # ��������� ���������� �������
        # ����� �������� ��������� ����������� ������� �������������
        await subscription_service.increment_analysis_usage(user_id)
        
        # ��������� �����
        response = {
            "themes": themes,
            "styles": styles,
            "analyzed_posts_sample": post_texts[:5],  # ���������� ������ 5 ������ ��� �������
            "best_posting_time": "�� ����������", # � ���� ������ ���� �� ���������� ������ �������
            "analyzed_posts_count": len(post_texts),
            "message": f"������ �������� �� {round(time.time() - startTime, 2)} ������"
        }
        
        # ��������� ���������� ������� � Supabase
        try:
            if supabase:
                channel_analysis = {
                    "channel_name": username,
                    "themes": themes,
                    "styles": styles,
                    "analyzed_posts_sample": post_texts[:5],
                    "best_posting_time": "�� ����������",
                    "analyzed_posts_count": len(post_texts),
                    "user_id": user_id
                }
                
                result = await _execute_sql_direct(
                    f"""
                    INSERT INTO channel_analysis (
                        channel_name, themes, styles, analyzed_posts_sample, 
                        best_posting_time, analyzed_posts_count, user_id
                    ) 
                    VALUES (
                        '{username}', 
                        '{json.dumps(themes)}', 
                        '{json.dumps(styles)}', 
                        '{json.dumps(post_texts[:5])}',
                        '�� ����������', 
                        {len(post_texts)},
                        {user_id}
                    )
                    """
                )
                
                if result.get("status_code") not in [200, 201, 204]:
                    logger.error(f"������ ��� ���������� �������: {result}")
        except Exception as e:
            logger.error(f"������ ��� ���������� �������: {e}")
            # ���������� ����������, ��� ��� �������� ���������������� ��� ���������
        
        return response
        
    except HTTPException:
        # ������������ HTTPException ������
        raise
    except Exception as e:
        logger.error(f"������ ��� ������� ������: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=500, 
            detail=f"��������� ������ ��� ������� ������: {str(e)}"
        )

# --- ��������� ��������� ��������� �������� ��� ������������ ����������� ������ ---
@app.get("/")
async def root():
    """������������ ��������� �������� - ���������� index.html"""
    if SHOULD_MOUNT_STATIC:
        return FileResponse(os.path.join(static_folder, "index.html"))
    else:
        return {"message": "API ��������, �� ����������� ����� �� ���������. ���������� � API ��������."}

# --- ��������� API ��������� ��� ������ � ������� ---
@app.get("/posts", response_model=List[SavedPostResponse])
async def get_posts(request: Request, channel_name: Optional[str] = None):
    """��������� ����������� ������."""
    try:
        # ��������� telegram_user_id �� ����������
        telegram_user_id = request.headers.get("X-Telegram-User-Id")
        if not telegram_user_id:
            logger.warning("������ ������ ��� ������������� ������������ Telegram")
            raise HTTPException(status_code=401, detail="��� ������� � ������ ���������� �������������� ����� Telegram")
        
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")
        
        # ������ ������ � ���� ������
        query = supabase.table("saved_posts").select("*").eq("user_id", telegram_user_id)
        
        # ���� ������� ��� ������, ��������� �� ����
        if channel_name:
            query = query.eq("channel_name", channel_name)
            
        # ��������� ������
        result = query.order("target_date", desc=True).execute()
        
        # �������� ����������
        if not hasattr(result, 'data'):
            logger.error(f"������ ��� ��������� ������ �� ��: {result}")
            return []
            
        # === ���������: ������ ��� ��������� ��������� ����������� ===
        # ������ ������ � ���� ������, ���������� ��������� ������ �� saved_images
        # �������� ��������: ��� ������� saved_images ������������ ��� ��� �����
        query = supabase.table("saved_posts").select(
            "*, saved_images(*)" # <--- ����������� ��� ���� ����� � ��� ���� ���������� �����������
        ).eq("user_id", telegram_user_id)
        # === ����� ��������� ===
        
        # ���� ������� ��� ������, ��������� �� ����
        if channel_name:
            query = query.eq("channel_name", channel_name)
            
        # ��������� ������
        result = query.order("target_date", desc=True).execute()
        
        # �������� ����������
        if not hasattr(result, 'data'):
            logger.error(f"������ ��� ��������� ������ �� ��: {result}")
            return []
            
        # === ���������: ��������� ������ ��� ��������� ������ ����������� ===
        posts_with_images = []
        for post_data in result.data:
            # ������� ������ SavedPostResponse �� �������� ������ �����
            response_item = SavedPostResponse(**post_data)
            
            # ���������, ���� �� ��������� ������ ����������� � ��� �� ������
            image_relation_data = post_data.get("saved_images")
            
            # === ��������: ����������� �� ������ INFO ===
            logger.info(f"��������� ����� ID: {response_item.id}. ��������� ������ �����������: {image_relation_data}")
            # === ����� ��������� ===
            
            if image_relation_data and isinstance(image_relation_data, dict):
                # ������� ������ PostImage �� ������ saved_images
                # ��������, ��� ����� ������������� ������ PostImage
                try:
                    # --- ���������: ��������� alt_description, ����� alt ---
                    alt_text = image_relation_data.get("alt_description") or image_relation_data.get("alt")
                    # --- ����� ��������� ---
                    response_item.selected_image_data = PostImage(
                        id=image_relation_data.get("id"),
                        url=image_relation_data.get("url"),
                        preview_url=image_relation_data.get("preview_url"),
                        alt=alt_text, # <--- ���������� �������������� alt_text
                        author=image_relation_data.get("author"), # � saved_images ��� 'author'
                        author_url=image_relation_data.get("author_url"),
                        source=image_relation_data.get("source")
                    )
                    # === ��������: ����������� �� ������ INFO ===
                    logger.info(f"������� ������� selected_image_data ��� ����� {response_item.id} � ������������ ID: {response_item.selected_image_data.id}")
                    # === ����� ��������� ===
                except Exception as mapping_error:
                     logger.error(f"������ ��� �������� PostImage ��� ����� {response_item.id}: {mapping_error}")
                     logger.error(f"������ �����������: {image_relation_data}")
                     response_item.selected_image_data = None # ������� ��� ������
            else:
                # ���� ���� 'saved_images' ����������� ��� ����, selected_image_data �������� None
                response_item.selected_image_data = None
                # ��������, ���� ������� ����������� (�.�. saved_image_id �� None), �� ��� ���
                if post_data.get("saved_image_id"):
                    logger.warning(f"��� ����� {post_data['id']} ���� saved_image_id, �� ��������� ������ ����������� �� ���� �������� ��� �����. ��������� ������: {image_relation_data}")


            posts_with_images.append(response_item)
            
        return posts_with_images
        # === ����� ��������� ===
        
    except Exception as e:
        logger.error(f"������ ��� ��������� ������: {e}")
        # === ���������: ���������� HTTPException ��� ����������� ������ ===
        raise HTTPException(status_code=500, detail=str(e))
        # === ����� ���������� ===

@app.post("/posts", response_model=SavedPostResponse)
async def create_post(request: Request, post_data: PostData):
    """�������� ������ �����."""
    try:
        # === ���������: �������������� ���������� ����� ����� ��������� ===
        try:
            logger.info("����� fix_schema ����� ��������� �����...")
            fix_result = await fix_schema()
            if not fix_result.get("success"):
                logger.warning(f"�� ������� ��������/��������� ����� ����� ��������� �����: {fix_result}")
                # ����� ������, ��������� �� �������� ��� ���. ���� ����������.
            else:
                logger.info("��������/���������� ����� ����� ��������� ����� ��������� �������.")
        except Exception as pre_save_fix_err:
            logger.error(f"������ ��� ������ fix_schema ����� ��������� �����: {pre_save_fix_err}", exc_info=True)
            # ����������, �� �������� ������
        # === ����� ���������� ===

        # === ���������: ����� ����� ���������� ����� ===
        logger.info("��������� ����� ����� fix_schema, ����� ���� PostgREST �����...")
        await asyncio.sleep(0.7) # ����� 0.7 �������
        # === ����� ���������� ===

        # ��������� telegram_user_id �� ����������
        telegram_user_id = request.headers.get("X-Telegram-User-Id")
        if not telegram_user_id:
            logger.warning("������ �������� ����� ��� ������������� ������������ Telegram")
            raise HTTPException(status_code=401, detail="��� �������� ����� ���������� �������������� ����� Telegram")
        
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")
        
        # ��������� ������ ����������� ��������
        selected_image = post_data.selected_image_data
        
        # ������� ������� � ��������� ������� ����� ��� ����������
        post_to_save = post_data.dict(exclude={"selected_image_data"}) # ��������� ������ �����������
        post_to_save["user_id"] = telegram_user_id
        post_to_save["id"] = str(uuid.uuid4()) # ���������� ID ��� ������ �����
        
        # === ���������: ��������� target_date ===
        if not post_to_save.get("target_date"):
            logger.warning(f"�������� ������ target_date ��� ������ ����� {post_to_save['id']}, ������������� � NULL.")
            post_to_save["target_date"] = None
        else:
            # ������������� ����� �������� ��������� ������� YYYY-MM-DD, ���� �����
            try:
                datetime.strptime(post_to_save["target_date"], '%Y-%m-%d')
            except ValueError:
                logger.error(f"������������ ������ target_date: {post_to_save['target_date']} ��� ����� {post_to_save['id']}. ������������� � NULL.")
                post_to_save["target_date"] = None
        # === ����� ���������� ===
        
        # --- ������: ��������� ���������� ����������� --- 
        saved_image_id = None
        if selected_image:
            try:
                # --- �������: �������� ������� ������� external_id --- 

                # ���������, ���������� �� ����������� � ����� URL (����� �������)
                image_check = None
                if selected_image.url:
                    image_check_result = supabase.table("saved_images").select("id").eq("url", selected_image.url).limit(1).execute()
                    if hasattr(image_check_result, 'data') and len(image_check_result.data) > 0:
                        image_check = image_check_result.data[0]
                # --- ����� �������� �� URL ---

                if image_check:
                    # ����������� ��� ����������, ���������� ��� ID (UUID)
                    saved_image_id = image_check["id"]
                    logger.info(f"���������� ������������ ����������� {saved_image_id} (URL: {selected_image.url}) ��� �����")
                else:
                    # ����������� �� �������, ��������� �����
                    # ���������� ����� UUID ��� ����� ��
                    new_internal_id = str(uuid.uuid4()) 
                    # --- �������: ������ � external_id --- 
                    
                    image_data_to_save = {
                        "id": new_internal_id, # ���������� ��� UUID
                        "url": selected_image.url,
                        "preview_url": selected_image.preview_url or selected_image.url,
                        "alt": selected_image.alt or "",
                        "author": selected_image.author or "", # ������������� 'author' � PostImage
                        "author_url": selected_image.author_url or "",
                        "source": selected_image.source or "frontend_selection",
                        "user_id": telegram_user_id,
                        # --- �������: external_id ---
                    }
                    
                    image_result = supabase.table("saved_images").insert(image_data_to_save).execute()
                    if hasattr(image_result, 'data') and len(image_result.data) > 0:
                        saved_image_id = new_internal_id # ���������� ��� ID ��� �����
                        logger.info(f"��������� ����� ����������� {saved_image_id} ��� �����")
                    else:
                        logger.error(f"������ ��� ���������� ������ �����������: {image_result}")
                        raise HTTPException(status_code=500, detail=f"������ ��� ���������� ������ �����������: {getattr(image_result, 'error', 'Unknown error')}")
            except Exception as img_err:
                logger.error(f"������ ��� ���������/���������� �����������: {img_err}")
                raise HTTPException(status_code=500, detail=f"������ ��� ���������/���������� �����������: {str(img_err)}")
        # --- �����: ��������� ���������� ����������� --- 

        # ������� ������ ���� �� ������ ��� ���������� �����
        post_to_save.pop('image_url', None)
        post_to_save.pop('images_ids', None)
        
        # === ��������� ������ ===
        # ��������� ID ������������ ����������� � ������ �����
        post_to_save["saved_image_id"] = saved_image_id
        # === ��������� ����� ===
        
        # === ��������� ������: ����������� ������ ����� ����������� ===
        logger.info(f"������������ ������ ��� ���������� � saved_posts: {post_to_save}")
        # === ����� ���������� ===

        # === ��������: ����� �������� ������ ===
        try:
            logger.info(f"��������� insert � saved_posts ��� ID {post_to_save['id']}...")
            # === ����������: �������� ������ ===
            result = supabase.table("saved_posts").insert(post_to_save).execute()
            logger.info(f"Insert ��������. Status: {result.status_code if hasattr(result, 'status_code') else 'N/A'}")
        except APIError as e:
            logger.error(f"������ APIError ��� insert � saved_posts: {e}")
            # ������������� � ��������, ����� ������� ������ ����� 500 �������
            raise HTTPException(status_code=500, detail=f"������ �� ��� �������� �����: {e.message}")
        except Exception as general_e:
            logger.error(f"�������������� ������ ��� insert � saved_posts: {general_e}")
            raise HTTPException(status_code=500, detail=f"�������������� ������ �� ��� �������� �����: {str(general_e)}")
        
        # === ��������: ����� ������ ������ ===
        # �������� ����������
        if not hasattr(result, 'data') or len(result.data) == 0:
            logger.error(f"������ ��� ���������� ����� {post_to_save['id']}: ����� Supabase ���� ��� �� �������� ������.")
            last_error_details = f"Status: {result.status_code if hasattr(result, 'status_code') else 'N/A'}"
            raise HTTPException(status_code=500, detail=f"�� ������� ��������� ����. {last_error_details}")
        # === ����� ��������� ===

        created_post = result.data[0]
        post_id = created_post["id"]
        
        logger.info(f"������������ {telegram_user_id} ������ ����: {post_data.topic_idea}")
        
        # ���������� ������ ���������� �����, ����������� ������� �����������
        response_data = SavedPostResponse(**created_post)
        if saved_image_id and selected_image: # ���� ���� ������� � ���������/������� �����������
             response_data.selected_image_data = selected_image # ���������� �������� ������ �����������
        elif saved_image_id: # ���� ����������� ���� �������, �� �� �������� (������������, �� �� ������ ������)
             # �������� �������� ������ ����������� �� ��
             img_data_res = supabase.table("saved_images").select("id, url, preview_url, alt, author, author_url, source").eq("id", saved_image_id).maybe_single().execute()
             if img_data_res.data:
                  response_data.selected_image_data = PostImage(**img_data_res.data)

        return response_data
        
    except HTTPException as http_err:
        # ������������� HTTP ����������, ����� �� ������� � ����� Exception
        raise http_err
    except Exception as e:
        logger.error(f"������ ��� �������� �����: {e}\n{traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"���������� ������ ������� ��� �������� �����: {str(e)}")

@app.put("/posts/{post_id}", response_model=SavedPostResponse)
async def update_post(post_id: str, request: Request, post_data: PostData):
    """���������� ������������� �����."""
    try:
        # === ���������: �������������� ���������� ����� ����� ��������� ===
        try:
            logger.info(f"����� fix_schema ����� ����������� ����� {post_id}...")
            fix_result = await fix_schema()
            if not fix_result.get("success"):
                logger.warning(f"�� ������� ��������/��������� ����� ����� ����������� ����� {post_id}: {fix_result}")
            else:
                logger.info(f"��������/���������� ����� ����� ����������� ����� {post_id} ��������� �������.")
        except Exception as pre_update_fix_err:
            logger.error(f"������ ��� ������ fix_schema ����� ����������� ����� {post_id}: {pre_update_fix_err}", exc_info=True)
        # === ����� ���������� ===

        # === ���������: ����� ����� ���������� ����� ===
        logger.info(f"��������� ����� ����� fix_schema ��� ����� {post_id}, ����� ���� PostgREST �����...")
        await asyncio.sleep(0.7) # ����� 0.7 �������
        # === ����� ���������� ===

        # ��������� telegram_user_id �� ����������
        telegram_user_id = request.headers.get("X-Telegram-User-Id")
        if not telegram_user_id:
            logger.warning("������ ���������� ����� ��� ������������� ������������ Telegram")
            raise HTTPException(status_code=401, detail="��� ���������� ����� ���������� �������������� ����� Telegram")
        
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")
        
        # ���������, ��� ���� ����������� ������������
        post_check = supabase.table("saved_posts").select("id").eq("id", post_id).eq("user_id", telegram_user_id).execute()
        if not hasattr(post_check, 'data') or len(post_check.data) == 0:
            logger.warning(f"������� �������� ����� ��� �������������� ����: {post_id}")
            raise HTTPException(status_code=404, detail="���� �� ������ ��� ��� ���� �� ��� ��������������")
        
        # === ��������� ������ ��������� ����������� ===
        # ���������� getattr ��� ����������� �������, �� ������ ���� ���� ����������� � �������
        selected_image = getattr(post_data, 'selected_image_data', None)
        # ����, �����������, ���� �� ���� selected_image_data *����* �������� � �������
        image_field_provided_in_request = hasattr(post_data, 'selected_image_data')

        # ���������� ��� �������� ID �����������, ������� ����� ��������� � �����
        # ���������� None, ��������� ������ ���� ����������� �������������
        image_id_to_set_in_post = None
        image_processed = False # ����, ��� �� ���������� ������ ����������� �� �������

        if image_field_provided_in_request:
            image_processed = True # ��������, ��� ������ ����������� ���� � �������
            if selected_image: # ���� ����������� �������� � ��� �� None/������
                try:
                    # ���������, ���������� �� ����������� � ����� URL
                    image_check = None
                    if selected_image.url:
                        image_check_result = supabase.table("saved_images").select("id").eq("url", selected_image.url).limit(1).execute()
                        if hasattr(image_check_result, 'data') and len(image_check_result.data) > 0:
                            image_check = image_check_result.data[0]

                    if image_check:
                        image_id_to_set_in_post = image_check["id"]
                        logger.info(f"���������� ������������ ����������� {image_id_to_set_in_post} ��� ���������� ����� {post_id}")
                    else:
                        # ��������� ����� �����������
                        new_internal_id = str(uuid.uuid4())
                        image_data_to_save = {
                            "id": new_internal_id,
                            "url": selected_image.url,
                            "preview_url": selected_image.preview_url or selected_image.url,
                            "alt": selected_image.alt or "",
                            "author": selected_image.author or "",
                            "author_url": selected_image.author_url or "",
                            "source": selected_image.source or "frontend_selection",
                            "user_id": telegram_user_id,
                        }
                        image_result = supabase.table("saved_images").insert(image_data_to_save).execute()
                        if hasattr(image_result, 'data') and len(image_result.data) > 0:
                            image_id_to_set_in_post = new_internal_id
                            logger.info(f"��������� ����� ����������� {image_id_to_set_in_post} ��� ���������� ����� {post_id}")
                        else:
                            logger.error(f"������ ��� ���������� ������ ����������� ��� ���������� �����: {image_result}")
                            raise HTTPException(status_code=500, detail=f"������ ��� ���������� ������ �����������: {getattr(image_result, 'error', 'Unknown error')}")
                except Exception as img_err:
                    logger.error(f"������ ��� ���������/���������� ����������� ��� ���������� �����: {img_err}")
                    raise HTTPException(status_code=500, detail=f"������ ��� ���������/���������� �����������: {str(img_err)}")
            else: # ���� selected_image_data ������� ��� null ��� ������ ������
                image_id_to_set_in_post = None # ���� ���������, ��� ����� ����� �������
                logger.info(f"� ������� �� ���������� ����� {post_id} �������� ������ ����������� (None/null). ����� ����� �������.")
        # ���� image_field_provided_in_request == False, �� image_processed �������� False,
        # � �� �� ����� ��������� ���� saved_image_id � post_to_update �����.

        # ������� ������� � ��������� ������� ����� ��� ����������
        # ��������� selected_image_data, �.�. ��� �� ����� ������ � saved_posts
        post_to_update = post_data.dict(exclude={"selected_image_data", "image_url", "images_ids"})
        post_to_update["updated_at"] = datetime.now().isoformat()

        # ��������� target_date (�������� ��� ����)
        if "target_date" in post_to_update and not post_to_update.get("target_date"):
            logger.warning(f"�������� ������ target_date ��� ���������� ����� {post_id}, ������������� � NULL.")
            post_to_update["target_date"] = None
        elif post_to_update.get("target_date"):
            try:
                datetime.strptime(post_to_update["target_date"], '%Y-%m-%d')
            except ValueError:
                logger.error(f"������������ ������ target_date: {post_to_update['target_date']} ��� ���������� ����� {post_id}. ������������� � NULL.")
                post_to_update["target_date"] = None

        # ��������� saved_image_id ������ ���� ���� selected_image_data ���� ���� �������� � �������
        if image_processed:
            # ��������� ���� saved_image_id ���������, ���������� ��� ��������� �����������
            # ���� ���� �������� ������ �����������, image_id_to_set_in_post ����� None, � ����� ���������
            post_to_update["saved_image_id"] = image_id_to_set_in_post
            logger.info(f"���� saved_image_id ��� ����� {post_id} ����� ��������� ��: {image_id_to_set_in_post}")
        else:
            # ���� ���� selected_image_data �� ���� �������� � �������,
            # �� ������� ���� saved_image_id � post_to_update.
            # ��������, ��� ��� ����� ��� � ������� ��� ����������, ����� �� �������� ������������ �������� � ��.
            post_to_update.pop("saved_image_id", None)
            logger.info(f"���� selected_image_data �� ������������� � ������� �� ���������� ����� {post_id}. ���� saved_image_id �� ����� ��������.")

        # ����������� ������ ����� �����������
        logger.info(f"������������ ������ ��� ���������� � saved_posts: {post_to_update}")

        # ���������� UPDATE �������
        try:
            logger.info(f"��������� update � saved_posts ��� ID {post_id}...")
            result = supabase.table("saved_posts").update(post_to_update).eq("id", post_id).eq("user_id", telegram_user_id).execute()
            logger.info(f"Update ��������. Status: {result.status_code if hasattr(result, 'status_code') else 'N/A'}")
        except APIError as e:
            logger.error(f"������ APIError ��� update � saved_posts ��� ID {post_id}: {e}")
            raise HTTPException(status_code=500, detail=f"������ �� ��� ���������� �����: {e.message}")
        except Exception as general_e:
            logger.error(f"�������������� ������ ��� update � saved_posts ��� ID {post_id}: {general_e}")
            raise HTTPException(status_code=500, detail=f"�������������� ������ �� ��� ���������� �����: {str(general_e)}")
        
        # �������� ����������
        if not hasattr(result, 'data') or len(result.data) == 0:
            logger.error(f"������ ��� ���������� ����� {post_id}: ����� Supabase ���� ��� �� �������� ������.")
            last_error_details = f"Status: {result.status_code if hasattr(result, 'status_code') else 'N/A'}"
            raise HTTPException(status_code=500, detail=f"�� ������� �������� ����. {last_error_details}")

        updated_post = result.data[0]
        logger.info(f"������������ {telegram_user_id} ������� ����: {post_id}")

        # ���������� ������ ������������ �����, ����������� ����������� ������� �����������
        response_data = SavedPostResponse(**updated_post)
        # �������� ID ����������� �� ������������ ����� (updated_post),
        # ��� ��� ��� ����� ���������� ��� �������� �������
        final_image_id = updated_post.get("saved_image_id")

        if final_image_id:
            # ���� ID ����, �������� �������� ������ ����������� �� ��
            img_data_res = supabase.table("saved_images").select("id, url, preview_url, alt, author, author_url, source").eq("id", final_image_id).maybe_single().execute()
            if img_data_res.data:
                 try: # ��������� try-except ��� ��������
                     alt_text = img_data_res.data.get("alt_description") or img_data_res.data.get("alt")
                     response_data.selected_image_data = PostImage(
                          id=img_data_res.data.get("id"),
                          url=img_data_res.data.get("url"),
                          preview_url=img_data_res.data.get("preview_url"),
                          alt=alt_text,
                          author=img_data_res.data.get("author"),
                          author_url=img_data_res.data.get("author_url"),
                          source=img_data_res.data.get("source")
                     )
                 except Exception as mapping_err:
                     logger.error(f"������ ��� �������� ������ ����������� �� �� ��� ������������ ����� {post_id}: {mapping_err}")
                     response_data.selected_image_data = None
            else:
                 logger.warning(f"�� ������� �������� ������ ����������� {final_image_id} �� �� ��� ������ �� ���������� ����� {post_id}")
                 response_data.selected_image_data = None
        else:
            # ���� final_image_id ����������� � ����������� �����, selected_image_data �������� None
            response_data.selected_image_data = None

        return response_data

    except HTTPException as http_err:
        raise http_err
    except Exception as e:
        logger.error(f"������ ��� ���������� ����� {post_id}: {e}\n{traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"���������� ������ ������� ��� ���������� �����: {str(e)}")

@app.delete("/posts/{post_id}")
async def delete_post(post_id: str, request: Request):
    """�������� �����."""
    try:
        # ��������� telegram_user_id �� ����������
        telegram_user_id = request.headers.get("X-Telegram-User-Id")
        if not telegram_user_id:
            logger.warning("������ �������� ����� ��� ������������� ������������ Telegram")
            raise HTTPException(status_code=401, detail="��� �������� ����� ���������� �������������� ����� Telegram")
        
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")
        
        # ���������, ��� ���� ����������� ������������
        post_check = supabase.table("saved_posts").select("id").eq("id", post_id).eq("user_id", telegram_user_id).execute()
        if not hasattr(post_check, 'data') or len(post_check.data) == 0:
            logger.warning(f"������� ������� ����� ��� �������������� ����: {post_id}")
            raise HTTPException(status_code=404, detail="���� �� ������ ��� ��� ���� �� ��� ��������")
        
        # --- :      --- 
        try:
            delete_links_res = supabase.table("post_images").delete().eq("post_id", post_id).execute()
            logger.info(f"������� {len(delete_links_res.data) if hasattr(delete_links_res, 'data') else 0} ������ ��� ���������� ����� {post_id}")
        except Exception as del_link_err:
            logger.error(f"������ ��� �������� ������ post_images ��� ����� {post_id} ����� ��������� �����: {del_link_err}")
            # ���������� �������� �����, �� �������� ������
        # --- ����� ���������� ---
        
        # �������� �� Supabase
        result = supabase.table("saved_posts").delete().eq("id", post_id).execute()
        
        # �������� ����������
        if not hasattr(result, 'data'):
            logger.error(f"������ ��� �������� �����: {result}")
            raise HTTPException(status_code=500, detail="������ ��� �������� �����")
            
        logger.info(f"������������ {telegram_user_id} ������ ���� {post_id}")
        return {"message": "���� ������� ������"}
        
    except HTTPException as http_err:
        # ������������� HTTP ����������
        raise http_err
    except Exception as e:
        logger.error(f"������ ��� �������� �����: {e}\n{traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=f"���������� ������ ������� ��� �������� �����: {str(e)}")

# --- ����������� ��������� ���� ����� SPA ��� ������������ ����������� ������ (� ����� �����) ---
@app.get("/{rest_of_path:path}")
async def serve_spa(rest_of_path: str):
    """����������� ��� ������� � ����� SPA, ��������� index.html"""
    # ���������, ���� �� ����������� ����
    if SHOULD_MOUNT_STATIC:
        file_path = os.path.join(static_folder, rest_of_path)
        if os.path.exists(file_path) and os.path.isfile(file_path):
            return FileResponse(file_path)
        
        # ���� ���� �� ������, ���������� index.html ��� ��������� SPA-��������
        return FileResponse(os.path.join(static_folder, "index.html"))
    else:
        return {"message": "API ��������, �� ����������� ����� �� ���������. ���������� � API ��������."}

# --- ������� ��� ��������� �������� ���� ��� ������ ����������� ---
async def generate_image_keywords(text: str, topic: str, format_style: str) -> List[str]:
    """��������� �������� ���� ��� ������ ����������� � ������� ��."""
    try:
        # ���� ��� API-�����, ������ ������ � ��������� �����
        if not OPENROUTER_API_KEY:
            words = re.findall(r'\b[�-��-�a-zA-Z]{4,}\b', text.lower())
            stop_words = ["�", "�", "��", "�", "��", "���", "�", "��", "���", "���", "���", "���"]
            filtered_words = [w for w in words if w not in stop_words]
            
            # ���� ���� ���� � ������, ��������� ��
            result = []
            if topic:
                result.append(topic)
            if format_style:
                result.append(format_style)
                
            # ��������� ��������� �������� ����� ������������� ����
            word_counts = Counter(filtered_words)
            common_words = [word for word, _ in word_counts.most_common(3)]
            result.extend(common_words)
            
            # ��������� ����������� ����� ��� ������������ �����������
            context_words = ["business", "abstract", "professional", "technology", "creative", "modern"]
            result.extend(random.sample(context_words, 2))
            
            return result
        
        # �������������� ������ OpenAI ����� OpenRouter
        client = AsyncOpenAI(
            base_url="https://openrouter.ai/api/v1",
            api_key=OPENROUTER_API_KEY
        )
        
        # ������� ������ ��� ��������� �������� ����
        system_prompt = """���� ������ - ������������� 2-3 ����������� �������� ����� ��� ������ �����������.
        �������� ����� ������ ����� �������� �������� ������ � ���� �������������� ��� ������ �������� �����������.
        ������� �������� ���������� ��������������� �� ���������� �����, ���� ���� ����� �� �������.
        ������ ������: ������ �������� ���� ����� �������."""
        
        user_prompt = f"""����� �����: {text[:300]}...

�������� �����: {topic}
������ �����: {format_style}

����� 2-3 ������ �������� ����� �� ���������� ����� ��� ������ ���������� �����������. ������ �������� �����, ��� ����������."""
        
        # ������ � API
        response = await client.chat.completions.create(
            model="deepseek/deepseek-chat",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.7,
            max_tokens=100,
            timeout=15,
            extra_headers={
                "HTTP-Referer": "https://content-manager.onrender.com",
                "X-Title": "Smart Content Assistant"
            }
        )
        
        # �������� � ������������ �����
        keywords_text = response.choices[0].message.content.strip()
        keywords_list = re.split(r'[,;\n]', keywords_text)
        keywords = [k.strip() for k in keywords_list if k.strip()]
        
        # ���� �� ������� �������� �������� �����, ���������� �������� �������
        if not keywords:
            logger.warning("�� ������� �������� �������� ����� �� API, ���������� �������� �������")
            return [topic, format_style] + random.sample(["business", "abstract", "professional"], 2)
        
        logger.info(f"������������� �������� ����� ��� ������ �����������: {keywords}")
        return keywords
        
    except Exception as e:
        logger.error(f"������ ��� ��������� �������� ���� ��� ������ �����������: {e}")
        # � ������ ������ ���������� ������� �������� �����
        return [topic, format_style, "concept", "idea"]

# --- ������� ��� ������ ����������� � Unsplash ---
async def search_unsplash_images(query: str, count: int = 5, topic: str = "", format_style: str = "", post_text: str = "") -> List[FoundImage]:
    """����� ����������� � Unsplash API � ���������� ������� �������� ����."""
    # ��������� ������� �����
    if not UNSPLASH_ACCESS_KEY:
        logger.warning(f"����� ����������� � Unsplash ����������: ����������� UNSPLASH_ACCESS_KEY")
        # ���������� �������� � �������������-�������������
        placeholder_images = []
        for i in range(min(count, 5)):  # ������������ �� 5 ��������
            placeholder_images.append(FoundImage(
                id=f"placeholder_{i}",
                source="unsplash",
                preview_url=f"https://via.placeholder.com/150x100?text=Image+{i+1}",
                regular_url=f"https://via.placeholder.com/800x600?text=Unsplash+API+key+required",
                description=f"Placeholder image {i+1}",
                author_name="Demo",
                author_url="https://unsplash.com"
            ))
        return placeholder_images
    
    try:
        # ���������� �� ��� ��������� ������ �������� ����
        keywords = []
        if post_text:
            keywords = await generate_image_keywords(post_text, topic, format_style)
        
        # ���� �� ������� ������������� �������� ����� ��� �� ����, ��������� �������� ������
        if not keywords or len(keywords) < 2:
            if query:
                keywords.append(query)
            
            # ��������� ���� � ������, ���� ��� ����
            if topic and topic not in keywords:
                keywords.append(topic)
            if format_style and format_style not in keywords:
                keywords.append(format_style)
                
            # ���� ��� ��� ���� �������� ����, ��������� �����������
            if len(keywords) < 3:
                context_words = ["business", "abstract", "professional", "technology"]
                keywords.extend(random.sample(context_words, min(2, len(context_words))))
        
        logger.info(f"�������� �������� ����� ��� ������: {keywords}")
        
        unsplash_api_url = f"https://api.unsplash.com/search/photos"
        per_page = min(count * 3, 30) 
        headers = {
            "Authorization": f"Client-ID {UNSPLASH_ACCESS_KEY}",
            "Accept-Version": "v1"
        }
        
        all_photos = []
        async with httpx.AsyncClient(timeout=15.0) as client: # �������� �������
            for keyword in keywords[:3]:
                try:
                    logger.info(f"����� ����������� � Unsplash �� �������: {keyword}")
                    response = await client.get(
                        unsplash_api_url,
                        headers=headers,
                        params={"query": keyword, "per_page": per_page}
                    )
                    
                    if response.status_code != 200:
                        logger.error(f"������ ��� ������� � Unsplash API: {response.status_code} {response.text}")
                        continue
                    
                    results = response.json()
                    if 'results' in results and results['results']:
                        all_photos.extend(results['results'])
                    else:
                        logger.warning(f"��� ����������� �� ������� '{keyword}'")
                         
                except httpx.ReadTimeout:
                    logger.warning(f"������� ��� ������ ����������� �� ��������� ����� '{keyword}'")
                    continue
                except Exception as e:
                    logger.error(f"������ ��� ���������� ������� � Unsplash �� ��������� ����� '{keyword}': {e}")
                    continue
        
        if not all_photos:
            logger.warning(f"�� ������� ����������� �� ���� �������� ������")
            return []
            
        random.shuffle(all_photos)
        selected_photos = all_photos[:count] # ����� ������ ���������� *�����* �������������
        
        images = []
        for photo in selected_photos:
            # ������ ��������� ������� FoundImage ��� ���������� � ��
            images.append(FoundImage(
                id=photo['id'],
                source="unsplash",
                preview_url=photo['urls']['small'],
                regular_url=photo['urls']['regular'],
                description=photo.get('description') or photo.get('alt_description') or query,
                author_name=photo['user']['name'],
                author_url=photo['user']['links']['html']
            ))
        
        logger.info(f"������� � �������� {len(images)} ����������� �� {len(all_photos)} � Unsplash ��� �����������")
        return images
    except Exception as e:
        logger.error(f"������ ��� ������ ����������� � Unsplash: {e}")
        return []

# --- Endpoint ��� ��������� ������� ����� ---
@app.post("/generate-post-details", response_model=PostDetailsResponse)
async def generate_post_details(
    request: Request, 
    req: GeneratePostDetailsRequest,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    """���������� ������ ����� �� ��������� ���� � �������"""
    # �������� ������������� ������������ �� ���������
    user_id_str = request.headers.get("x-telegram-user-id")
    if not user_id_str:
        raise HTTPException(status_code=401, detail="��������� �����������")
    
    try:
        user_id = int(user_id_str)
    except ValueError:
        raise HTTPException(status_code=400, detail="������������ ������������� ������������")
    
    # ���������, ����� �� ������������ ������������ �����
    can_generate = await subscription_service.can_generate_post(user_id)
    if not can_generate:
            raise HTTPException(
            status_code=403, 
            detail=f"��������� ����� ���������� ��������� ������ ({FREE_POST_LIMIT}). ����������� ��������."
        )
    
    try:
        logger.info(f"������ �� ��������� ������� �����: ����={req.topic_idea}, ������={req.format_style}")
        
        # ��������� ��������� �������
        topic = req.topic_idea
        format_style = req.format_style
        
        # ������� ������� ������ �� ������������ ������� ��������
        topic = clean_text_formatting(topic)
        format_style = clean_text_formatting(format_style)
        
        keywords = req.keywords or []
        post_samples = req.post_samples or []
        
        # ���� ��� �������� ����, ��������� �� �� ����
        if not keywords and topic:
            # �������� �������� �������� ����� �� ����
            ai_keywords = await generate_image_keywords(topic, topic, format_style)
            if ai_keywords:
                keywords = ai_keywords
                
        start_time = time.time()
        
        # 1. ��������� ������ ===============
        # ��������� ������ ��� ��������� ������
        system_prompt = """
        �� - ���������� Telegram ������, ������� �� �������� ������������ ������. 
        ���� ������ - ������� ���� �� ��������� ����, � ��������� �������/�����.
        ����� ������ ���� ���������������, ������������� � ��������������� ����� ������.
        ��������� ������ ��� ��������� ������, �� ��������.
        ��������� �������������� ������ (������, ������) ��� �������.
        ���� ������ ���� �� ������� ������� (�� 2000 ��������) � ������ �����������������.
        ����������� ������ ��������� � ������ ����� �� ������ ��� ������� ����������.
        """
        
        # �������������� ������� ������ ������
        examples_text = ""
        if post_samples and len(post_samples) > 0:
            # ������������ ���������� � ������ ��������
            limited_samples = post_samples[:2]  # �� ����� 2 ��������
            limited_samples = [sample[:1000] for sample in limited_samples]  # �� ����� 1000 �������� � ������
            
            examples_text = "������� ������ ������ (��� ���������� �����):\n\n"
            for i, sample in enumerate(limited_samples, 1):
                examples_text += f"������ {i}:\n{sample}\n\n"
        
        # ��������� ������ � ������
        user_prompt = f"""
        ����: {topic}
        ������/�����: {format_style}
        
        {examples_text if examples_text else ""}
        
        ������ ���� ��� Telegram ������ �� ��������� ���� � ��������� �������/�����.
        """
        
        # ������ ������ � OpenAI API
        try:
            # ������� ������� OpenAI � ���������� �� OpenRouter
        client = AsyncOpenAI(
            base_url="https://openrouter.ai/api/v1",
                api_key=OPENROUTER_API_KEY,
                http_client=httpx.AsyncClient(timeout=60.0)
        )
        
            response = await client.chat.completions.create(
                model="deepseek-ai/deepseek-coder-33b-instruct",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                max_tokens=1000,
                temperature=0.7,
                headers={
                    "HTTP-Referer": "https://t.me/content_manager", # �������� � �������
                    "X-Title": "Smart Content Assistant"
                }
            )
            
            # ��������� ��������������� �����
            generated_text = response.choices[0].message.content
            
            # ������� ����� �� ��������� �������� Markdown � ������ ����������
            generated_text = re.sub(r'^```.*$', '', generated_text, flags=re.MULTILINE)
            generated_text = re.sub(r'^```$', '', generated_text, flags=re.MULTILINE)
            generated_text = generated_text.strip()
            
            logger.info(f"����� ������� ������������, �����: {len(generated_text)} ��������")
            
        except OpenAIError as e:
            logger.error(f"������ OpenAI ��� ��������� ������: {e}")
            raise HTTPException(
                status_code=500, 
                detail=f"������ AI ��� ��������� ������: {str(e)}"
            )
        except Exception as e:
            logger.error(f"����������� ������ ��� ��������� ������: {e}")
            raise HTTPException(
                status_code=500, 
                detail=f"������ ��� ��������� ������: {str(e)}"
            )
            
        # 2. ����� ����������� ===============
        try:
            # ���� ����������� �� ������ �������� ����
            found_images = []
            
            # ��������� ��������� ������
            if keywords and len(keywords) > 0:
                # ��������� ������ �������� ���� �� 3 ��� ����� ������� ������
                search_keywords = keywords[:3]
                search_query = " ".join(search_keywords)
            else:
                # ���� �������� ����� �� ���� ������������� ��� �������������, ���������� ����
                search_query = topic
            
            # ������� ������ �� �������� ��������
            search_query = search_query.strip()
            search_query = re.sub(r'[^\w\s\-\']', ' ', search_query)
            search_query = re.sub(r'\s+', ' ', search_query).strip()
            
            # ���������, ��� ������ �� ������
            if search_query:
                # ���� ����������� �� Unsplash
                unsplash_images = await search_unsplash_images(
                    search_query, 
                    count=IMAGE_SEARCH_COUNT,  # ��������� ���������� � ������ �����
                    topic=topic,
                    format_style=format_style,
                    post_text=generated_text
                )
                
                if unsplash_images:
                    found_images.extend(unsplash_images)
                    
                logger.info(f"������� {len(found_images)} �����������")
            else:
                logger.warning("������ ��������� ������ ��� �����������, ����� ��������")
            except Exception as e:
            logger.error(f"������ ��� ������ �����������: {e}")
            # ���������� ����������, ��� ��� ����������� �� ��������
            
        # ��������� �����
        end_time = time.time()
        
        # ����� �������� ��������� ����������� ������� �������������
        await subscription_service.increment_post_usage(user_id)
        
        # ������������ ���������� ����������� � ������
        limited_images = found_images[:IMAGE_RESULTS_COUNT] if found_images else []
        
        return {
            "generated_text": generated_text,
            "found_images": limited_images,
            "message": f"����� � ����������� ������������� �� {round(end_time - start_time, 2)} ������",
            "channel_name": None  # ����� ���� ��������� � ���������� �� ������� �������
        }
        
    except HTTPException:
        # ������������ HTTPException ��������
        raise
    except Exception as e:
        logger.error(f"����������� ������ ��� ��������� ������� �����: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(
            status_code=500,
            detail=f"��������� ������ ��� ��������� ������� �����: {str(e)}"
        )

# --- ������� ��� ����������� �������������� � ������������ ����� ---
async def fix_existing_ideas_formatting():
    """���������� �������������� � ������������ �����."""
    if not supabase:
        logger.error("���������� ��������� ��������������: ������ Supabase �� ���������������")
        return
    
    try:
        # ��������� ���� ����
        result = supabase.table("suggested_ideas").select("id,topic_idea,format_style").execute()
        
        if not hasattr(result, 'data') or len(result.data) == 0:
            logger.info("��� ���� ��� ����������� ��������������")
            return
        
        fixed_count = 0
        for idea in result.data:
            original_topic = idea.get("topic_idea", "")
            original_format = idea.get("format_style", "")
            
            # ������� ��������������
            cleaned_topic = clean_text_formatting(original_topic)
            cleaned_format = clean_text_formatting(original_format)
            
            # ���� ����� ���������, ��������� ������
            if cleaned_topic != original_topic or cleaned_format != original_format:
                supabase.table("suggested_ideas").update({
                    "topic_idea": cleaned_topic,
                    "format_style": cleaned_format
                }).eq("id", idea["id"]).execute()
                fixed_count += 1
        
        logger.info(f"���������� �������������� � {fixed_count} �����")
    except Exception as e:
        logger.error(f"������ ��� ����������� ��������������: {e}")

# --- ������ ����������� �������������� ��� ������ ������� ---
@app.on_event("startup")
async def startup_event():
    """������ ������������� ��������� ��� ������ ����������."""
    logger.info("������ ������������� ���������...")
    
    # �������� � ���������� ����������� �������� (��������� ������������ ������)
    if supabase:
        if not await check_db_tables():
            logger.error("������ ��� �������� ������ � ���� ������!")
            # ���������� ������ ���������� ���� ��� ������
        else:
            logger.info("�������� ������ ���� ������ ��������� �������.")
    else:
        logger.warning("������ Supabase �� ���������������, �������� ������ ���������.")
    
    # ����������� �������������� � JSON �����
    # await fix_formatting_in_json_fields() # ��������� ��������, ���� �� �����
    
    logger.info("������������� �������� �������� �������")

    # --- ���������: ����� fix_schema ��� ������ --- 
    try:
        fix_result = await fix_schema()
        logger.info(f"��������� ��������/����������� ����� ��� ������: {fix_result}")
        if not fix_result.get("success"):
            logger.error("������ ��� ��������/����������� ����� �� ��� �������!")
            # ������, ������� �� ��������� ������ ��� ���.
            # ���� ���������� ������.
    except Exception as schema_fix_error:
        logger.error(f"���������� ��� ������ fix_schema �� ����� ������: {schema_fix_error}", exc_info=True)
    # --- ����� ���������� ---

# --- ������� ��� ����������� �������������� � ������������ ������ ---
async def fix_existing_posts_formatting():
    """���������� �������������� � ������������ ������."""
    if not supabase:
        logger.error("���������� ��������� �������������� ������: ������ Supabase �� ���������������")
        return
    
    try:
        # ��������� ���� ������
        result = supabase.table("saved_posts").select("id,topic_idea,format_style,final_text").execute()
        
        if not hasattr(result, 'data') or len(result.data) == 0:
            logger.info("��� ������ ��� ����������� ��������������")
            return
        
        fixed_count = 0
        for post in result.data:
            original_topic = post.get("topic_idea", "")
            original_format = post.get("format_style", "")
            original_text = post.get("final_text", "")
            
            # ������� ��������������
            cleaned_topic = clean_text_formatting(original_topic)
            cleaned_format = clean_text_formatting(original_format)
            cleaned_text = clean_text_formatting(original_text)
            
            # ���� ����� ���������, ��������� ������
            if (cleaned_topic != original_topic or 
                cleaned_format != original_format or 
                cleaned_text != original_text):
                supabase.table("saved_posts").update({
                    "topic_idea": cleaned_topic,
                    "format_style": cleaned_format,
                    "final_text": cleaned_text
                }).eq("id", post["id"]).execute()
                fixed_count += 1
        
        logger.info(f"���������� �������������� � {fixed_count} ������")
    except Exception as e:
        logger.error(f"������ ��� ����������� �������������� ������: {e}")

# --- �������� ��� ���������� ����������� ---
@app.post("/save-image", response_model=Dict[str, Any])
async def save_image(request: Request, image_data: Dict[str, Any]):
    """���������� ���������� �� ����������� � ���� ������."""
    try:
        # ��������� telegram_user_id �� ����������
        telegram_user_id = request.headers.get("X-Telegram-User-Id")
        if not telegram_user_id:
            logger.warning("������ ���������� ����������� ��� ������������� ������������ Telegram")
            raise HTTPException(status_code=401, detail="��� ���������� ����������� ���������� �������������� ����� Telegram")
        
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")
        
        # ��������� ������������� ������������ � ������ �����������
        image_data["user_id"] = telegram_user_id
        
        # ��������� ������� ������������ �����
        if not image_data.get("url"):
            raise HTTPException(status_code=400, detail="URL ����������� ����������")
        
        # ���� �� ������� id, ���������� ���
        if not image_data.get("id"):
            image_data["id"] = f"img_{str(uuid.uuid4())}"
        
        # ���� �� ������� preview_url, ���������� �������� URL
        if not image_data.get("preview_url"):
            image_data["preview_url"] = image_data["url"]
        
        # ��������� timestamp
        image_data["created_at"] = time.strftime("%Y-%m-%d %H:%M:%S")
        
        # ���������, ���������� �� ��� ����� �����������
        image_check = supabase.table("saved_images").select("id").eq("url", image_data["url"]).execute()
        
        if hasattr(image_check, 'data') and len(image_check.data) > 0:
            # ����������� ��� ����������, ���������� ��� id
            return {"id": image_check.data[0]["id"], "status": "exists"}
        
        # ��������� ���������� �� �����������
        result = supabase.table("saved_images").insert(image_data).execute()
        
        # �������� ����������
        if not hasattr(result, 'data') or len(result.data) == 0:
            logger.error(f"������ ��� ���������� �����������: {result}")
            raise HTTPException(status_code=500, detail="������ ��� ���������� �����������")
        
        logger.info(f"������������ {telegram_user_id} �������� ����������� {image_data.get('id')}")
        return result.data[0]
        
    except Exception as e:
        logger.error(f"������ ��� ���������� �����������: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# --- �������� ��� ��������� ���� ����������� ������������ ---
@app.get("/images", response_model=List[Dict[str, Any]])
async def get_user_images(request: Request, limit: int = 20):
    """��������� ���� ����������� ����������� ������������."""
    try:
        # ��������� telegram_user_id �� ����������
        telegram_user_id = request.headers.get("X-Telegram-User-Id")
        if not telegram_user_id:
            logger.warning("������ ��������� ����������� ������������ ��� �������������")
            raise HTTPException(status_code=401, detail="��� ��������� ����������� ���������� �������������� ����� Telegram")
        
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")
        
        # �������� ��� ����������� ������������
        result = supabase.table("saved_images").select("*").eq("user_id", telegram_user_id).limit(limit).execute()
        
        # ���� � ���������� ���� ������, ���������� ��
        if hasattr(result, 'data'):
            logger.info(f"�������� {len(result.data)} ����������� ��� ������������ {telegram_user_id}")
            return result.data
        
        return []
        
    except Exception as e:
        logger.error(f"������ ��� ��������� ����������� ������������: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# --- ����� ��������: ��������� ������ ����������� �� ID --- 
@app.get("/images/{image_id}", response_model=Dict[str, Any])
async def get_image_by_id(request: Request, image_id: str):
    """��������� ������ ������ ������������ ����������� �� ��� ID."""
    try:
        # ��������� telegram_user_id �� ����������
        telegram_user_id = request.headers.get("X-Telegram-User-Id")
        if not telegram_user_id:
            logger.warning("������ ��������� ����������� �� ID ��� �������������")
            raise HTTPException(status_code=401, detail="��� ��������� ����������� ���������� ��������������")
        
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")
        
        # �������� ����������� �� ID, �������� �������������� ������������
        result = supabase.table("saved_images").select("*").eq("id", image_id).eq("user_id", telegram_user_id).maybe_single().execute()
        
        # ���� ����������� �������, ���������� ���
        if result.data:
            logger.info(f"�������� ����������� {image_id} ��� ������������ {telegram_user_id}")
            return result.data
        else:
            logger.warning(f"����������� {image_id} �� ������� ��� �� ����������� ������������ {telegram_user_id}")
            raise HTTPException(status_code=404, detail="����������� �� ������� ��� ������ ��������")
            
    except Exception as e:
        logger.error(f"������ ��� ��������� ����������� �� ID {image_id}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# --- �������� ��� ��������� ����������� ����� ---
@app.get("/post-images/{post_id}", response_model=List[Dict[str, Any]])
async def get_post_images(request: Request, post_id: str):
    """��������� �����������, ��������� � ������."""
    try:
        # ��������� telegram_user_id �� ����������
        telegram_user_id = request.headers.get("X-Telegram-User-Id")
        if not telegram_user_id:
            logger.warning("������ ��������� ����������� ����� ��� ������������� ������������ Telegram")
            raise HTTPException(status_code=401, detail="��� ��������� ����������� ����� ���������� �������������� ����� Telegram")
        
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")
        
        # ��������� ������������� ����� � �������������� ������������
        post_check = supabase.table("saved_posts").select("id").eq("id", post_id).eq("user_id", telegram_user_id).execute()
        
        if not hasattr(post_check, 'data') or len(post_check.data) == 0:
            logger.warning(f"������� �������� ����������� ������ ��� ��������������� ����� {post_id}")
            raise HTTPException(status_code=404, detail="���� �� ������ ��� �� �� ������ � ���� �������")
        
        # �������� ����������� ����� ����� ������� ������
        result = supabase.table("post_images").select("saved_images(*)").eq("post_id", post_id).execute()
        
        # ���� � ���������� ���� ������ � ��� ����� ������ ���������, ��������� �����������
        images = []
        if hasattr(result, 'data') and len(result.data) > 0:
            for item in result.data:
                if "saved_images" in item and item["saved_images"]:
                    images.append(item["saved_images"])
        
        # ���� ����������� �� �������, ���������, ���� �� ������ ������ � ������ �����
        if not images:
            post_data = supabase.table("saved_posts").select("image_url").eq("id", post_id).execute()
            if hasattr(post_data, 'data') and len(post_data.data) > 0 and post_data.data[0].get("image_url"):
                images.append({
                    "id": f"direct_img_{post_id}",
                    "url": post_data.data[0]["image_url"],
                    "preview_url": post_data.data[0]["image_url"],
                    "alt": "����������� �����",
                    "source": "direct"
                })
        
        return images
        
    except Exception as e:
        logger.error(f"������ ��� ��������� ����������� �����: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# --- �������� ��� ������������� ����������� ����� ��� ������ ---
@app.get("/image-proxy/{image_id}")
async def proxy_image(request: Request, image_id: str, size: Optional[str] = None):
    """
    ���������� ����������� ����� ��� ������, ������� �������� URL.
    
    Args:
        image_id: ID ����������� � ���� ������
        size: ������ ����������� (small, medium, large)
    """
    try:
        # ��������� telegram_user_id �� ����������
        telegram_user_id = request.headers.get("X-Telegram-User-Id")
        if not telegram_user_id:
            logger.warning("������ ������������� ����������� ��� ������������� ������������ Telegram")
            raise HTTPException(status_code=401, detail="��� ������� � ����������� ���������� �������������� ����� Telegram")
        
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")
        
        # �������� ������ �� ����������� �� ����
        image_data = supabase.table("saved_images").select("*").eq("id", image_id).execute()
        
        if not hasattr(image_data, 'data') or len(image_data.data) == 0:
            logger.warning(f"����������� � ID {image_id} �� �������")
            raise HTTPException(status_code=404, detail="����������� �� �������")
        
        image = image_data.data[0]
        
        # �������� URL �����������
        image_url = image.get("url")
        if not image_url:
            logger.error(f"��� ����������� {image_id} �� ������ URL")
            raise HTTPException(status_code=500, detail="������ ����������� ����������")
        
        # ��������� ������ � �������� ������� ��� ��������� �����������
        async with aiohttp.ClientSession() as session:
            async with session.get(image_url) as response:
                if response.status != 200:
                    logger.error(f"������ ��� ��������� ����������� {image_id} �� URL {image_url}: {response.status}")
                    raise HTTPException(status_code=response.status, detail="�� ������� �������� �����������")
                
                # ���������� ��� ��������
                content_type = response.headers.get("Content-Type", "image/jpeg")
                
                # �������� ���������� �����������
                image_content = await response.read()
                
                # ���������� ����������� ��� �����
                return Response(content=image_content, media_type=content_type)
    
    except Exception as e:
        logger.error(f"������ ��� ������������� �����������: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# --- �������� ��� ��������� ���� ����������� ������������ ---
@app.get("/user-images", response_model=List[Dict[str, Any]])
async def get_user_images_legacy(request: Request, limit: int = 20):
    """
    ��������� ���� ����������� ������������ (���������� ��������).
    ������������ �� ����� �������� /images.
    """
    return await get_user_images(request, limit)

@app.post("/save-suggested-idea", response_model=Dict[str, Any])
async def save_suggested_idea(idea_data: Dict[str, Any], request: Request):
    telegram_user_id = request.headers.get("x-telegram-user-id")
    if not telegram_user_id:
        raise HTTPException(status_code=401, detail="Unauthorized")
    
    if not supabase:
        logging.error("Supabase client not initialized")
        raise HTTPException(status_code=500, detail="Database not initialized")
    
    try:
        # ������� �������������� ������ ����� �����������
        if "topic_idea" in idea_data:
            idea_data["topic_idea"] = clean_text_formatting(idea_data["topic_idea"])
        
        # ���������� ���������� ID ��� ����
        idea_id = f"idea_{int(time.time())}_{random.randint(1000, 9999)}"
        idea_data["id"] = idea_id
        idea_data["user_id"] = telegram_user_id
        idea_data["created_at"] = datetime.now().isoformat()
        
        # ��������� ���� � ���� ������
        result = supabase.table("suggested_ideas").insert(idea_data).execute()
        
        if hasattr(result, 'data') and result.data:
            logging.info(f"Saved idea with ID {idea_id}")
            return {"id": idea_id, "message": "Idea saved successfully"}
        else:
            logging.error(f"Failed to save idea: {result}")
            raise HTTPException(status_code=500, detail="Failed to save idea")
    except Exception as e:
        logging.error(f"Error saving idea: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error: {str(e)}")

async def check_db_tables():
    """�������� ������� ����������� ������ � ���� ������."""
    try:
        # �������� ������� ������� suggested_ideas
        result = supabase.table("suggested_ideas").select("id").limit(1).execute()
        logger.info("������� suggested_ideas ���������� � ��������.")
        
        # �������������� ���������� ����������� ��������
        try:
            move_temp_files.add_missing_columns()
            logger.info("�������� � ���������� ����������� �������� ���������.")
            
            # ����� ���������� ������� updated_at � ������� channel_analysis � ���������� ���� �����
            try:
                # ��������� URL � ����� Supabase
                supabase_url = os.getenv('SUPABASE_URL')
                supabase_key = os.getenv('SUPABASE_ANON_KEY')
                
                if supabase_url and supabase_key:
                    # ������ ������ ����� API
                    url = f"{supabase_url}/rest/v1/rpc/exec_sql_array_json"
                    headers = {
                        "apikey": supabase_key,
                        "Authorization": f"Bearer {supabase_key}",
                        "Content-Type": "application/json"
                    }
                    
                    # SQL-������� ��� ���������� ������� � ���������� ����
                    sql_query = """
                    ALTER TABLE channel_analysis 
                    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();
                    
                    NOTIFY pgrst, 'reload schema';
                    """
                    
                    response = requests.post(url, json={"query": sql_query}, headers=headers)
                    
                    if response.status_code in [200, 204]:
                        logger.info("������� updated_at ������� �������� � ��� ����� ��������")
                    else:
                        logger.warning(f"������ ��� ���������� ������� updated_at: {response.status_code} - {response.text}")
            except Exception as column_e:
                logger.warning(f"������ ��� ����� ���������� ������� updated_at: {str(column_e)}")
            
        except Exception as e:
            logger.warning(f"������ ��� ���������� ����������� ��������: {str(e)}")
            
        return True
    except Exception as e:
        logger.error(f"������ ��� �������� ������: {str(e)}")
        return False

async def fix_formatting_in_json_fields():
    """����������� �������������� � JSON �����."""
    try:
        # ���������� �������������� � ������������ �����
        await fix_existing_ideas_formatting()
        
        # ���������� �������������� � ������������ ������
        await fix_existing_posts_formatting()
    except Exception as e:
        logger.error(f"������ ��� ����������� ��������������: {str(e)}")
        # ���������� ������ ���������� ���� ��� ������

@app.get("/fix-schema")
async def fix_schema():
    """����������� ����� ���� ������: ���������� ����������� ������� � ���������� ���� �����."""
    logger.info("������ ����������� ����� ��...")
    results = {
        "success": False,
        "message": "�� ���������������",
        "response_code": 500,
        "operations": []
    }
    try:
        if not supabase:
            logger.error("������ Supabase �� ���������������")
            results["message"] = "������: �� ������� ������������ � ���� ������"
            return results

        # ������ ������ ��� ����������
        sql_commands = [
            # ���������� preview_url � saved_images
            {
                "name": "add_preview_url_to_saved_images",
                "query": "ALTER TABLE saved_images ADD COLUMN IF NOT EXISTS preview_url TEXT;"
            },
            # ���������� updated_at � channel_analysis
            {
                "name": "add_updated_at_to_channel_analysis",
                "query": "ALTER TABLE channel_analysis ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();"
            },
            # ���������� external_id � saved_images
            {
                "name": "add_external_id_to_saved_images",
                "query": "ALTER TABLE saved_images ADD COLUMN IF NOT EXISTS external_id TEXT;"
            },
            # ���������� saved_image_id � saved_posts
            {
                "name": "add_saved_image_id_to_saved_posts",
                "query": "ALTER TABLE saved_posts ADD COLUMN IF NOT EXISTS saved_image_id UUID REFERENCES saved_images(id) ON DELETE SET NULL;"
            }
        ]

        all_commands_successful = True
        saved_image_id_column_verified = False # ���� ��� �������� �������

        for command in sql_commands:
            logger.info(f"���������� ������� SQL: {command['name']}")
            result = await _execute_sql_direct(command['query'])
            status_code = result.get("status_code")
            op_result = {
                "name": command['name'],
                "status_code": status_code,
                "error": result.get("error")
            }
            results["operations"] .append(op_result)

            if status_code not in [200, 204]:
                logger.warning(f"������ ��� ���������� {command['name']}: {status_code} - {result.get('error')}")
                all_commands_successful = False
            else:
                logger.info(f"������� {command['name']} ��������� ������� (��� ������� ��� ������������).")

            # === ���������: �������� ������������� ������� saved_image_id ===
            if command['name'] == 'add_saved_image_id_to_saved_posts' and status_code in [200, 204]:
                logger.info("�������� ������������ ������� ������� 'saved_image_id' � 'saved_posts'...")
                verification_query = "SELECT column_name FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'saved_posts' AND column_name = 'saved_image_id';"
                verify_result = await _execute_sql_direct(verification_query)
                verify_status = verify_result.get("status_code")
                op_result_verify = {
                    "name": "verify_saved_image_id_column",
                    "status_code": verify_status,
                    "data": verify_result.get("data"),
                    "error": verify_result.get("error")
                }
                results["operations"].append(op_result_verify)

                if verify_status == 200 and verify_result.get("data") and len(verify_result["data"]) > 0:
                    logger.info("�������� �������: ������� 'saved_image_id' ������� � 'saved_posts'.")
                    saved_image_id_column_verified = True
        else:
                    logger.error("�������� ��������: ������� 'saved_image_id' �� ������� � 'saved_posts' ����� ������� ALTER TABLE!")
                    logger.error(f"��������� ��������: {op_result_verify}")
                    all_commands_successful = False # ������� �������� ����������, ���� ������� �� ���������
            # === ����� ���������� ===

        # ������������� ��������� ��� ����� ����� ���� ���������
        logger.info("�������������� ���������� ���� ����� PostgREST...")
        # === ���������: ��������� ���������� ���� ===
        notify_successful = True
        for i in range(3): # ��������� ��������� ��� � ���������
            refresh_result = await _execute_sql_direct("NOTIFY pgrst, 'reload schema';")
            status_code = refresh_result.get("status_code")
            results["operations"] .append({
                 "name": f"notify_pgrst_attempt_{i+1}",
                 "status_code": status_code,
                 "error": refresh_result.get("error")
            })
            if status_code not in [200, 204]:
                 logger.warning(f"������� {i+1} ���������� ���� �� �������: {status_code} - {refresh_result.get('error')}")
                 notify_successful = False
            else:
                 logger.info(f"������� {i+1} ���������� ���� �������.")
                 notify_successful = True # ���������� ����� �������� �������
                 break # ������� �� �����, ���� �������
            await asyncio.sleep(0.5) # ��������� ����� ����� ���������
        # === ����� ��������� ===

        if all_commands_successful and saved_image_id_column_verified and notify_successful:
            results["success"] = True
            results["message"] = "����� ���������/����������, ������� 'saved_image_id' ������������, ��� ��������."
            results["response_code"] = 200
            logger.info("����������� �����, �������� ������� � ���������� ���� ��������� �������.")
        elif not saved_image_id_column_verified:
             results["success"] = False
             results["message"] = "������: �� ������� ��������/����������� ������� 'saved_image_id' � ������� 'saved_posts'."
             results["response_code"] = 500
             logger.error(f"������ ��� ��������/���������� ������� saved_image_id. ������: {results['operations']}")
        else:
            results["success"] = False
            results["message"] = "�� ����� ����������� ����� ��� ���������� ���� �������� ������."
            results["response_code"] = 500
            logger.error(f"������ �� ����� ����������� ����� ��� ���������� ����. ������: {results['operations']}")

        return results

    except Exception as e:
        logger.error(f"����������� ������ ��� ����������� ����� ��: {e}", exc_info=True)
        results["success"] = False
        results["message"] = f"������ ��� ����������� �����: {e}"
        results["response_code"] = 500
        return results

@app.get("/check-schema")
async def check_schema():
    """�������� ��������� ������� channel_analysis � ����������� ���� �����."""
    try:
        # ��������� URL � ����� Supabase
        supabase_url = os.getenv('SUPABASE_URL')
        supabase_key = os.getenv('SUPABASE_ANON_KEY')
        
        if not supabase_url or not supabase_key:
            return {"success": False, "message": "�� ������� ���������� ��������� SUPABASE_URL ��� SUPABASE_ANON_KEY"}
        
        # ������ ������ ����� API
        url = f"{supabase_url}/rest/v1/rpc/exec_sql_array_json"
        headers = {
            "apikey": supabase_key,
            "Authorization": f"Bearer {supabase_key}",
            "Content-Type": "application/json"
        }
        
        # SQL ������ ��� �������� ��������� �������
        table_structure_query = """
        SELECT column_name, data_type, is_nullable
        FROM information_schema.columns
        WHERE table_name = 'channel_analysis'
        AND table_schema = 'public'
        ORDER BY ordinal_position;
        """
        
        # SQL ������ ��� �������� ���� �����
        cache_query = """
        SELECT pg_notify('pgrst', 'reload schema');
        SELECT 'Cache reloaded' as status;
        """
        
        # ���������� ������� ��� ��������� ��������� �������
        table_response = requests.post(url, json={"query": table_structure_query}, headers=headers)
        
        # ���������� ������� ��� ���������� ���� �����
        cache_response = requests.post(url, json={"query": cache_query}, headers=headers)
        
        # �������� ������� ������� updated_at
        updated_at_exists = False
        columns = []
        if table_response.status_code == 200:
            try:
                table_data = table_response.json()
                columns = table_data
                for column in table_data:
                    if column.get('column_name') == 'updated_at':
                        updated_at_exists = True
                        break
            except Exception as parse_error:
                logger.error(f"������ ��� ������� ������: {parse_error}")
        
        # ���� ������� updated_at ���, ��������� ��
        if not updated_at_exists:
            add_column_query = """
            ALTER TABLE channel_analysis 
            ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();
            
            NOTIFY pgrst, 'reload schema';
            """
            add_column_response = requests.post(url, json={"query": add_column_query}, headers=headers)
            
            # ��������� �������� ��������� ����� ���������� �������
            table_response2 = requests.post(url, json={"query": table_structure_query}, headers=headers)
            if table_response2.status_code == 200:
                try:
                    columns = table_response2.json()
                    for column in columns:
                        if column.get('column_name') == 'updated_at':
                            updated_at_exists = True
                            break
                except Exception:
                    pass
        
        return {
            "success": True,
            "table_structure": columns,
            "updated_at_exists": updated_at_exists,
            "cache_response": {
                "status_code": cache_response.status_code,
                "response": cache_response.json() if cache_response.status_code == 200 else None
            }
        }
            
    except Exception as e:
        logger.error(f"���������� ��� �������� �����: {str(e)}")
        return {"success": False, "message": f"������: {str(e)}"}

@app.get("/recreate-schema")
async def recreate_schema():
    """������������ ������� channel_analysis � ������ ����������."""
    try:
        # ��������� URL � ����� Supabase
        supabase_url = os.getenv('SUPABASE_URL')
        supabase_key = os.getenv('SUPABASE_ANON_KEY')
        
        if not supabase_url or not supabase_key:
            return {"success": False, "message": "�� ������� ���������� ��������� SUPABASE_URL ��� SUPABASE_ANON_KEY"}
        
        # ������ ������ ����� API
        url = f"{supabase_url}/rest/v1/rpc/exec_sql_array_json"
        headers = {
            "apikey": supabase_key,
            "Authorization": f"Bearer {supabase_key}",
            "Content-Type": "application/json"
        }
        
        # SQL ������ ��� �������� ��������� ����� ������
        backup_query = """
        CREATE TEMPORARY TABLE temp_channel_analysis AS
        SELECT * FROM channel_analysis;
        SELECT COUNT(*) AS backup_rows FROM temp_channel_analysis;
        """
        
        # SQL ������ ��� �������� � ������������ ������� � ������ ����������
        recreate_query = """
        DROP TABLE IF EXISTS channel_analysis;
        
        CREATE TABLE channel_analysis (
            id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
            user_id BIGINT NOT NULL,
            channel_name TEXT NOT NULL,
            themes JSONB DEFAULT '[]'::jsonb,
            styles JSONB DEFAULT '[]'::jsonb,
            sample_posts JSONB DEFAULT '[]'::jsonb,
            best_posting_time TEXT,
            analyzed_posts_count INTEGER DEFAULT 0,
            is_sample_data BOOLEAN DEFAULT FALSE,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            UNIQUE(user_id, channel_name)
        );
        
        CREATE INDEX idx_channel_analysis_user_id ON channel_analysis(user_id);
        CREATE INDEX idx_channel_analysis_channel_name ON channel_analysis(channel_name);
        CREATE INDEX idx_channel_analysis_updated_at ON channel_analysis(updated_at);
        
        NOTIFY pgrst, 'reload schema';
        SELECT 'Table recreated' AS status;
        """
        
        # SQL ������ ��� �������������� ������ �� ��������� �����
        restore_query = """
        INSERT INTO channel_analysis (
            id, user_id, channel_name, themes, styles, sample_posts, 
            best_posting_time, analyzed_posts_count, is_sample_data, created_at
        )
        SELECT 
            id, user_id, channel_name, themes, styles, sample_posts, 
            best_posting_time, analyzed_posts_count, is_sample_data, created_at
        FROM temp_channel_analysis
        ON CONFLICT (user_id, channel_name) DO NOTHING;
        
        SELECT COUNT(*) AS restored_rows FROM channel_analysis;
        DROP TABLE IF EXISTS temp_channel_analysis;
        """
        
        # ���������� ������� ��� �������� ��������� ����� ������
        backup_response = requests.post(url, json={"query": backup_query}, headers=headers)
        backup_success = backup_response.status_code == 200
        backup_data = backup_response.json() if backup_success else None
        
        # ���������� ������� ��� ������������ �������
        recreate_response = requests.post(url, json={"query": recreate_query}, headers=headers)
        recreate_success = recreate_response.status_code == 200
        
        # ���� �������� ��������� ����� �������, �������� ������������ ������
        restore_data = None
        restore_success = False
        if backup_success:
            restore_response = requests.post(url, json={"query": restore_query}, headers=headers)
            restore_success = restore_response.status_code == 200
            restore_data = restore_response.json() if restore_success else None
        
        # ��������� ���������� ���� �����
        cache_query = """
        NOTIFY pgrst, 'reload schema';
        SELECT pg_sleep(1);
        NOTIFY pgrst, 'reload schema';
        SELECT 'Cache reloaded twice' as status;
        """
        cache_response = requests.post(url, json={"query": cache_query}, headers=headers)
        
        return {
            "success": recreate_success,
            "backup": {
                "success": backup_success,
                "data": backup_data
            },
            "recreate": {
                "success": recreate_success,
                "data": recreate_response.json() if recreate_success else None
            },
            "restore": {
                "success": restore_success,
                "data": restore_data
            },
            "cache_reload": {
                "success": cache_response.status_code == 200,
                "data": cache_response.json() if cache_response.status_code == 200 else None
            }
        }
            
    except Exception as e:
        logger.error(f"���������� ��� ������������ �����: {str(e)}")
        return {"success": False, "message": f"������: {str(e)}"}

# --- ����� �������� ��� ���������� ���������� ���� --- 
class SaveIdeasRequest(BaseModel):
    ideas: List[Dict[str, Any]]
    channel_name: Optional[str] = None # ����� �������� ��� ������ ���� ���

@app.post("/save-suggested-ideas", response_model=Dict[str, Any])
async def save_suggested_ideas_batch(payload: SaveIdeasRequest, request: Request):
    """��������� ������ ������������ ���� � ���� ������."""
    telegram_user_id = request.headers.get("x-telegram-user-id")
    if not telegram_user_id:
        raise HTTPException(status_code=401, detail="Unauthorized")

    if not supabase:
        logger.error("Supabase client not initialized")
        raise HTTPException(status_code=500, detail="Database not initialized")

    saved_count = 0
    errors = []
    saved_ids = []

    ideas_to_save = payload.ideas
    channel_name = payload.channel_name
    logger.info(f"������� ������ �� ���������� {len(ideas_to_save)} ���� ��� ������ {channel_name}")

    # --- ������: �������� ������ ���� ��� ����� ������ ����� ����������� ����� --- 
    if channel_name:
        try:
            delete_result = supabase.table("suggested_ideas")\
                .delete()\
                .eq("user_id", telegram_user_id)\
                .eq("channel_name", channel_name)\
                .execute()
            logger.info(f"������� {len(delete_result.data)} ������ ���� ��� ������ {channel_name}")
        except Exception as del_err:
            logger.error(f"������ ��� �������� ������ ���� ��� ������ {channel_name}: {del_err}")
            # �� ��������� ����������, �� �������� ������
            errors.append(f"������ �������� ������ ����: {str(del_err)}")
    # --- �����: �������� ������ ���� --- 

    # --- ���������: ����� fix_schema ����� �������� --- 
    try:
        logger.info("����� fix_schema ��������������� ����� ����������� ����...")
        fix_result = await fix_schema()
        if not fix_result.get("success"):
            logger.warning(f"�� ������� ��������/��������� ����� ����� ����������� ����: {fix_result}")
            # �� ���������, �� ��������. ������, ������ �����, ���������� ��� �������.
            errors.append("��������������: �� ������� ���������/�������� ����� ����� �����������.")
        else:
            logger.info("��������/���������� ����� ����� ����������� ���� ��������� �������.")
    except Exception as pre_save_fix_err:
        logger.error(f"������ ��� ������ fix_schema ����� ����������� ����: {pre_save_fix_err}", exc_info=True)
        errors.append(f"������ �������� ����� ����� �����������: {str(pre_save_fix_err)}")
    # --- ����� ���������� ---

    records_to_insert = []
    for idea_data in ideas_to_save:
        try:
            # ������� �������������� ������ ����� �����������
            topic_idea = clean_text_formatting(idea_data.get("topic_idea", ""))
            format_style = clean_text_formatting(idea_data.get("format_style", ""))

            if not topic_idea: # ���������� ���� ��� ����
                continue

            # ���������� ���������� ID ��� ���� (���������� UUID)
            idea_id = str(uuid.uuid4())
            record = {
                "id": idea_id,
                "user_id": telegram_user_id,
                "channel_name": idea_data.get("channel_name") or channel_name, # ���������� �� ���� ��� �����
                "topic_idea": topic_idea,
                "format_style": format_style,
                "relative_day": idea_data.get("day"),
                "created_at": datetime.now().isoformat(),
                "is_detailed": idea_data.get("is_detailed", False),
            }
            records_to_insert.append(record)
            saved_ids.append(idea_id)

        except Exception as e:
            errors.append(f"������ ���������� ���� {idea_data.get('topic_idea')}: {str(e)}")
            logger.error(f"������ ���������� ���� {idea_data.get('topic_idea')}: {str(e)}")

    if not records_to_insert:
        logger.warning("��� ���� ��� ���������� ����� ���������.")
        return {"message": "��� ���������� ���� ��� ����������.", "saved_count": 0, "errors": errors}

    try:
        # ��������� ��� �������������� ������ ����� ��������
        result = supabase.table("suggested_ideas").insert(records_to_insert).execute()

        if hasattr(result, 'data') and result.data:
            saved_count = len(result.data)
            logger.info(f"������� ��������� {saved_count} ���� ������.")
            return {"message": f"������� ��������� {saved_count} ����.", "saved_count": saved_count, "saved_ids": saved_ids, "errors": errors}
        else:
            error_detail = getattr(result, 'error', 'Unknown error')
            logger.error(f"������ ��� ����-���������� ����: {error_detail}")
            errors.append(f"������ ��� ����-����������: {error_detail}")
            # �������� ��������� �� �����, ���� ���� �� ������
            logger.warning("������� ��������� ���� �� �����...")
            saved_count_single = 0
            saved_ids_single = []
            for record in records_to_insert:
                 try:
                     single_result = supabase.table("suggested_ideas").insert(record).execute()
                     if hasattr(single_result, 'data') and single_result.data:
                         saved_count_single += 1
                         saved_ids_single.append(record['id'])
                     else:
                         single_error = getattr(single_result, 'error', 'Unknown error')
                         errors.append(f"������ ���������� ���� {record.get('topic_idea')}: {single_error}")
                         logger.error(f"������ ���������� ���� {record.get('topic_idea')}: {single_error}")
                 except Exception as single_e:
                     errors.append(f"���������� ��� ���������� ���� {record.get('topic_idea')}: {str(single_e)}")
                     logger.error(f"���������� ��� ���������� ���� {record.get('topic_idea')}: {str(single_e)}")
                     
            logger.info(f"��������� {saved_count_single} ���� �� �����.")
            return {
                 "message": f"��������� {saved_count_single} ���� (��������� � �������).", 
                 "saved_count": saved_count_single, 
                 "saved_ids": saved_ids_single, 
                 "errors": errors
            }

    except Exception as e:
        logger.error(f"���������� ��� ����-���������� ����: {str(e)}")
        raise HTTPException(status_code=500, detail=f"���������� ��� ����-����������: {str(e)}")

async def check_db_tables():
    """�������� ������� ����������� ������ � ���� ������."""
    try:
        # �������� ������� ������� suggested_ideas
        result = supabase.table("suggested_ideas").select("id").limit(1).execute()
        logger.info("������� suggested_ideas ���������� � ��������.")
        
        # �������������� ���������� ����������� ��������
        try:
            move_temp_files.add_missing_columns()
            logger.info("�������� � ���������� ����������� �������� ���������.")
            
            # ����� ���������� ������� updated_at � ������� channel_analysis � ���������� ���� �����
            try:
                # ��������� URL � ����� Supabase
                supabase_url = os.getenv('SUPABASE_URL')
                supabase_key = os.getenv('SUPABASE_ANON_KEY')
                
                if supabase_url and supabase_key:
                    # ������ ������ ����� API
                    url = f"{supabase_url}/rest/v1/rpc/exec_sql_array_json"
                    headers = {
                        "apikey": supabase_key,
                        "Authorization": f"Bearer {supabase_key}",
                        "Content-Type": "application/json"
                    }
                    
                    # SQL-������� ��� ���������� ������� � ���������� ����
                    sql_query = """
                    ALTER TABLE channel_analysis 
                    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();
                    
                    NOTIFY pgrst, 'reload schema';
                    """
                    
                    response = requests.post(url, json={"query": sql_query}, headers=headers)
                    
                    if response.status_code in [200, 204]:
                        logger.info("������� updated_at ������� �������� � ��� ����� ��������")
                    else:
                        logger.warning(f"������ ��� ���������� ������� updated_at: {response.status_code} - {response.text}")
            except Exception as column_e:
                logger.warning(f"������ ��� ����� ���������� ������� updated_at: {str(column_e)}")
            
        except Exception as e:
            logger.warning(f"������ ��� ���������� ����������� ��������: {str(e)}")
            
        return True
    except Exception as e:
        logger.error(f"������ ��� �������� ������: {str(e)}")
        return False

# --- ������� ����� ��� ��������, ���� �� ��� ---
UPLOADS_DIR = os.path.join(os.path.dirname(__file__), "uploads") # ���������� ������������� ���� ������ backend
os.makedirs(UPLOADS_DIR, exist_ok=True)
logger.info(f"����� ��� ����������� �����������: {os.path.abspath(UPLOADS_DIR)}")

# --- ����� �������� ��� �������� ����������� ---
@app.post("/upload-image")
async def upload_image(request: Request, file: UploadFile = File(...)):
    """��������� ���� ����������� � Supabase Storage."""
    telegram_user_id = request.headers.get("X-Telegram-User-Id")
    if not telegram_user_id:
        logger.warning("������ �������� ����������� ��� ������������� ������������ Telegram")
        raise HTTPException(status_code=401, detail="��� �������� ����������� ���������� �������������� ����� Telegram")

    if not supabase:
        logger.error("������ Supabase �� ���������������")
        raise HTTPException(status_code=500, detail="������: �� ������� ������������ � ���� ������")

    try:
        # �������� ���� �����
        content_type = file.content_type
        if not content_type or not content_type.startswith("image/"):
             logger.warning(f"������� ��������� �� �����������: {file.filename}, ���: {content_type}")
             raise HTTPException(status_code=400, detail="����������� ������ ����� ����������� (JPEG, PNG, GIF, WEBP)")

        # ���������� ���������� ��� �����/���� � ������, �������� ����������
        _, ext = os.path.splitext(file.filename)
        allowed_extensions = {".jpg", ".jpeg", ".png", ".gif", ".webp"}
        if ext.lower() not in allowed_extensions:
             logger.warning(f"������� ��������� ���� � ������������ �����������: {file.filename}")
             raise HTTPException(status_code=400, detail=f"������������ ���������� �����. ���������: {', '.join(allowed_extensions)}")

        # ��������� ���� ������ ������ (��������, public/<uuid>.<ext>)
        # 'public/' - �������������� ����� ������ ������ ��� �������� �����������
        storage_path = f"public/{uuid.uuid4()}{ext.lower()}"
        bucket_name = "post-images" # ��� ������ � Supabase Storage

        # ������ ���������� �����
        file_content = await file.read()
        # ���������� ��������� �����, ���� �� ����������� ����� (���� ����� �� �����)
        await file.seek(0)

        logger.info(f"������� �������� ����� � Supabase Storage: �����='{bucket_name}', ����='{storage_path}', ���='{content_type}'")

        # ��������� ���� � Supabase Storage
        # ���������� file_options ��� ��������� content-type
        upload_response = supabase.storage.from_(bucket_name).upload(
            path=storage_path,
            file=file_content,
            file_options={"content-type": content_type, "cache-control": "3600"} # ������������� ��� � �����������
        )

        # Supabase Python client v1 �� ���������� �������� ������ ��� ������, ��������� �� ����������
        # � v2 (���� ������������) ����� ����� ������. ���� ������������� �� ���������� ������.
        logger.info(f"���� ������� �������� � Supabase Storage (����� API: {upload_response}). ����: {storage_path}")

        # �������� ��������� URL ��� ������������ �����
        public_url_response = supabase.storage.from_(bucket_name).get_public_url(storage_path)

        if not public_url_response:
             logger.error(f"�� ������� �������� ��������� URL ��� �����: {storage_path}")
             raise HTTPException(status_code=500, detail="�� ������� �������� URL ��� ������������ �����.")

        public_url = public_url_response # � v1 get_public_url ���������� ������ URL

        logger.info(f"������������ {telegram_user_id} ������� �������� �����������: {storage_path}, URL: {public_url}")

        # ���������� ������ ��������� URL
        return {"url": public_url}

    except HTTPException as http_err:
        raise http_err
    except APIError as storage_api_err:
        logger.error(f"������ API Supabase Storage ��� �������� �����: {storage_api_err}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"������ ��������� ��� ��������: {storage_api_err.message}")
    except Exception as e:
        logger.error(f"�������������� ������ ��� �������� ����� � Supabase Storage: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"�� ������� ���������� �������� �����: {str(e)}")
    finally:
        # ����� ������� ���� � ����� ������
        if file and hasattr(file, 'close') and callable(file.close):
            await file.close()

# --- ��������� ������������ ����������� ������ (SPA) ---
# ��������, ��� ���� ��� ���� ����� ������������ /uploads
# ���� � ����� ������ ��������� (������������, ��� ��� �� ��� ������ ���� � � ����� frontend/dist)
static_folder = os.path.join(os.path.dirname(os.path.dirname(__file__)), "frontend", "dist")

# ���� ��� ������������ ������� � ����� �����
SHOULD_MOUNT_STATIC = os.path.exists(static_folder) and os.path.isdir(static_folder)

if SHOULD_MOUNT_STATIC:
    logger.info(f"����������� ����� SPA ����� ������������� �� �����: {static_folder}")
    try: # ����������: �������� ���� try...except
        app.mount("/", StaticFiles(directory=static_folder, html=True), name="static-spa") # ����������: ������ ������ `\`
        logger.info(f"����������� ����� SPA ������� ������������ � �������� ���� '/'")

        # ���� ������� ���������� ��� ��������� ����, ���� StaticFiles �� �����������
        @app.get("/") # ����������: ������ ������ `\`
        async def serve_index():
            index_path = os.path.join(static_folder, "index.html")
            if os.path.exists(index_path):
                 return FileResponse(index_path)
            else:
                 logger.error(f"���� index.html �� ������ � {static_folder}")
                 raise HTTPException(status_code=404, detail="Index file not found")

        # ���������� ��� ���� ��������� ����� SPA (���� StaticFiles(html=True) ������������)
        # ���� ���������� ���������� ���, ��� �� ���� ����������� ����� (/api, /uploads, etc.)
        @app.get("/{rest_of_path:path}") # ����������: ������ ������ `\`
        async def serve_spa_catch_all(request: Request, rest_of_path: str):
            # ��������� API ����, ����� �������� ���������� (�� ������ ������)
            # ���������, �� ���������� �� ���� � /api/, /docs, /openapi.json ��� /uploads/
            if rest_of_path.startswith("api/") or \
               rest_of_path.startswith("docs") or \
               rest_of_path.startswith("openapi.json") or \
               rest_of_path.startswith("uploads/"):
                 # ���� ��� �� ������ �����������, �.�. ����� API/docs/uploads ���������� ����, �� ��� ����������
                 # �������� ������� ������� � API ����� SPA catch-all
                 logger.debug(f"������ � '{rest_of_path}' ���������� SPA catch-all, �� �������������� (API/Docs/Uploads).")
                 # ����� ������� 404, ����� FastAPI ��� ����� ���������� ����������, ���� �� ����
                 raise HTTPException(status_code=404, detail="Not Found (SPA Catch-all exclusion)")


            index_path = os.path.join(static_folder, "index.html")
            if os.path.exists(index_path):
                # �������� ������� index.html ��� SPA ����
                logger.debug(f"���������� index.html ��� SPA ����: '{rest_of_path}'")
                return FileResponse(index_path)
            else:
                logger.error(f"���� index.html �� ������ � {static_folder} ��� ���� {rest_of_path}")
                raise HTTPException(status_code=404, detail="Index file not found")

        logger.info("����������� ��� SPA ���������.")

    except RuntimeError as mount_error: # ����������: �������� ���� except
        logger.error(f"������ ��� ������������ ����������� ������ SPA: {mount_error}. ��������, ��� 'static-spa' ��� ������������ ��� ���� '/' �����.")
    except Exception as e: # ����������: �������� ���� except
        logger.error(f"�������������� ������ ��� ������������ ����������� ������ SPA: {e}")
else:
    logger.warning(f"����� ����������� ������ SPA �� �������: {static_folder}")
    logger.warning("������������ SPA ��������� �� ���������. ������ API endpoints ��������.")

# --- ������ ������� (������ � ����� �����) ---
if __name__ == "__main__":
    # Проверка переменных окружения при запуске
    def check_required_env_vars():
        """Проверяет наличие необходимых переменных окружения"""
        required_vars = ["DATABASE_URL", "TELEGRAM_BOT_TOKEN"]
        missing_vars = []
        
        for var in required_vars:
            if not os.getenv(var):
                missing_vars.append(var)
        
        if missing_vars:
            print(f"КРИТИЧЕСКАЯ ОШИБКА: Отсутствуют необходимые переменные окружения: {', '.join(missing_vars)}")
            print("Создайте файл .env на основе .env.example и заполните требуемые значения")
            sys.exit(1)
        
        logger.info("Проверка переменных окружения пройдена успешно")
    
    # Вызываем проверку переменных окружения
    check_required_env_vars()
    
    port = int(os.getenv("PORT", 8000))
    logger.info(f"    {port}")
    uvicorn.run("main:app", host="0.0.0.0", port=port, reload=True) # reload=True  

#    
@app.get("/subscription/status", response_model=SubscriptionStatusResponse)
async def get_subscription_status(
    request: Request,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    """Получает статус подписки пользователя"""
    # Проверка идентификации пользователя из заголовков
    user_id_str = request.headers.get("x-telegram-user-id")
    init_data = request.headers.get("x-telegram-init-data")
    
    user_id = None
    
    # Если передан initData, валидируем его и получаем user_id
    if init_data:
        validated_user_id = get_user_id_from_init_data(init_data)
        if validated_user_id:
            user_id = validated_user_id
            logger.info(f"Пользователь {user_id} идентифицирован через initData")
    
    # Если не удалось получить user_id из initData, используем заголовок
    if not user_id and user_id_str:
        try:
            user_id = int(user_id_str)
            logger.info(f"Пользователь {user_id} идентифицирован через заголовок x-telegram-user-id")
        except ValueError:
            raise HTTPException(status_code=400, detail="Некорректный идентификатор пользователя")
    
    # Если не удалось получить идентификатор ни одним из способов
    if not user_id:
        raise HTTPException(status_code=401, detail="Требуется аутентификация")
    
    try:
        # Получение статуса подписки пользователя
        subscription = await subscription_service.get_subscription(user_id)
        
        # Получение статистики использования
        usage = await subscription_service.get_user_usage(user_id)
        
        return {
            "has_subscription": subscription is not None,
            "analysis_count": usage["analysis_count"] if usage else 0,
            "post_generation_count": usage["post_generation_count"] if usage else 0,
            "subscription_end_date": subscription["end_date"].isoformat() if subscription else None
        }
    except Exception as e:
        logger.error(f"Ошибка при получении статуса подписки: {e}")
        raise HTTPException(status_code=500, detail=f"Ошибка при получении статуса подписки: {str(e)}")

@app.post("/subscription/create", response_model=Dict[str, Any])
async def create_subscription(
    request: CreateSubscriptionRequest,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    """������� ����� �������� ������������"""
    try:
        # ������� ��������
        subscription = await subscription_service.create_subscription(
            user_id=request.user_id,
            payment_id=request.payment_id
        )
        
        return {
            "success": True,
            "subscription_id": subscription["id"],
            "end_date": subscription["end_date"].isoformat()
        }
    except Exception as e:
        logger.error(f"������ ��� �������� ��������: {e}")
        raise HTTPException(status_code=500, detail=f"������ ��� �������� ��������: {str(e)}")

@app.post("/telegram/webhook", response_model=Dict[str, Any])
async def telegram_webhook(
    request: WebAppDataRequest,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    """������������ webhook �� Telegram WebApp"""
    try:
        # �������� ������ ������ ��� �������
        logger.info(f"������� webhook ������: {request}")
        
        # �������� ������ �� Telegram
        data_str = request.data
        user_data = request.user
        
        if not user_data or not user_data.get("id"):
            raise HTTPException(status_code=400, detail="�� ������ ID ������������")
        
        user_id = int(user_data["id"])
        logger.info(f"��������� webhook ��� ������������ ID: {user_id}")
        
        # ������ JSON �� data
        try:
            data = json.loads(data_str)
            logger.info(f"���������� ������: {data}")
        except json.JSONDecodeError:
            logger.error(f"�� ������� ���������� JSON: {data_str}")
            raise HTTPException(status_code=400, detail="������������ ������ �� WebApp")
        
        # ��������� ��� ��������
        if data.get("type") == "subscribe":
            # ���� ��� �������� ��������
            tier = data.get("tier")
            logger.info(f"������ �� �������� ����: {tier}")
            
            # �������� ��������� �������� ���� �������� ��� ������������
            # if tier != "premium_monthly":
            #     raise HTTPException(status_code=400, detail="���������������� ��� ��������")
            
            # ���������� ���������� ������������� �������
            payment_id = f"tg_stars_{int(time.time())}_{user_id}"
            logger.info(f"������������ payment_id: {payment_id}")
            
            # ������� ��������
            subscription = await subscription_service.create_subscription(
                user_id=user_id,
                payment_id=payment_id
            )
            
            logger.info(f"�������� ������� �������: {subscription}")
            
            return {
                "success": True,
                "message": "�������� ������� ������������",
                "subscription_id": subscription["id"],
                "end_date": subscription["end_date"].isoformat()
            }
        else:
            logger.error(f"����������� ��� ��������: {data.get('type')}")
            raise HTTPException(status_code=400, detail="����������� ��� ��������")
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"������ ��� ��������� webhook: {e}")
        raise HTTPException(status_code=500, detail=f"������ ��� ��������� webhook: {str(e)}")

# ���������� telegram ���� ��� ��������� ��������
@app.post("/bot/webhook", response_model=Dict[str, Any])
async def bot_webhook(
    request: Request,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    """������������ webhook �� Telegram ����"""
    try:
        # �������� ������ �� Telegram Bot API
        data = await request.json()
        logger.info(f"������� webhook �� ����: {data}")
        
        # ���������, ���� �� ��������� � ����������
        if "message" not in data:
            return {"ok": True}
        
        message = data["message"]
        
        # ���������, ���� �� ����� ��������� � ���������� �� �� � ������� /start
        if "text" not in message:
            return {"ok": True}
        
        text = message["text"]
        user_id = message["from"]["id"]
        
        # ������������ ������� /start � ���������� ������
        if text.startswith("/start pay_"):
            try:
                # ��������� � ���������� ��������
                param_base64 = text.replace("/start pay_", "")
                param_json = base64.b64decode(param_base64).decode('utf-8')
                param_data = json.loads(param_json)
                
                logger.info(f"������� �������� ������: {param_data}")
                
                # ��������� ���������� ���������
                if param_data.get("action") == "buy_subscription" and param_data.get("user_id") and param_data.get("amount"):
                    # ������� ���������� ID �������
                    payment_id = f"stars_payment_{int(time.time())}_{user_id}"
                    
                    # ������� �������� ��� ������������
                    user_id_from_param = param_data.get("user_id")
                    subscription = await subscription_service.create_subscription(
                        user_id=int(user_id_from_param),
                        payment_id=payment_id
                    )
                    
                    logger.info(f"�������� ������� ������� ����� ����: {subscription}")
                    
                    # ���������� �������� ��������� ������������
                    # ����� ������ ���� ��� ��� �������� ��������� ����� Bot API
                    # ��������:
                    # await send_message_to_user(user_id, "�������� ������� ������������!")
                    
                    return {
                        "success": True,
                        "message": "�������� ������� ������������ ����� ����"
                    }
                else:
                    logger.error(f"������������ �������� ������: {param_data}")
                    return {"ok": True}
            except Exception as e:
                logger.error(f"������ ��� ��������� ��������� ������: {e}")
                return {"ok": True}
        
        return {"ok": True}
    except Exception as e:
        logger.error(f"������ ��� ��������� webhook �� ����: {e}")
        return {"ok": True}  # ������ ���������� �����, ����� �������� ��������� ��������

# ����� �������� ��� ������ ��������� ������� ����� Bot API
@app.post("/generate-invoice", response_model=Dict[str, Any])
async def generate_invoice(
    request: Request,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    """���������� ������ ��� ������ �������� Stars"""
    try:
        # �������� ������ �� �������
        data = await request.json()
        
        # ��������� ������������ ����
        if not data.get("user_id") or not data.get("amount"):
            raise HTTPException(status_code=400, detail="����������� ������������ ���������")
        
        user_id = data["user_id"]
        amount = int(data["amount"])
        
        logger.info(f"��������� ������� ��� ������������ {user_id} �� ����� {amount} Stars")
        
        # ������� ���������� ID �������
        payment_id = f"stars_invoice_{int(time.time())}_{user_id}"
        
        # �������� ����� ���� �� ���������� ���������
        bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
        if not bot_token:
            raise HTTPException(status_code=500, detail="����������� ����� ����")
        
        # ������� ��������� � �������� ������
        title = "�������� Premium"
        description = "�������� Premium �� Smart Content Assistant �� 1 �����"
        
        # ��������� URL ��� API ������� �� �������� �������
        api_url = f"https://api.telegram.org/bot{bot_token}/createInvoiceLink"
        
        # ��������� ��������� �������
        payload = {
            "title": title,
            "description": description,
            "payload": payment_id,
            "provider_token": "", # ��� Stars ��������� ������
            "currency": "XTR", # XTR - ��� ��� Stars
            "prices": [{"label": "�������� Premium", "amount": amount * 100}], # � �������� (1 Star = 100 ������)
            "max_tip_amount": 0,
            "suggested_tip_amounts": [],
            "photo_url": "https://smart-content-assistant.onrender.com/static/premium_sub.jpg", # URL ����������� ��� �����
            "photo_width": 600,
            "photo_height": 400,
            "need_name": False,
            "need_phone_number": False,
            "need_email": False,
            "need_shipping_address": False,
            "send_phone_number_to_provider": False,
            "send_email_to_provider": False,
            "is_flexible": False
        }
        
        # ���������� ������ � Telegram Bot API
        async with httpx.AsyncClient() as client:
            response = await client.post(api_url, json=payload)
            response_data = response.json()
        
        # ��������� ���������� �������
        if not response_data.get("ok"):
            logger.error(f"������ ��� �������� �������: {response_data}")
            raise HTTPException(status_code=500, detail=f"������ API Telegram: {response_data.get('description')}")
        
        # �������� URL �������
        invoice_url = response_data.get("result")
        
        return {
            "success": True,
            "invoice_url": invoice_url,
            "payment_id": payment_id
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"������ ��� ��������� �������: {e}")
        raise HTTPException(status_code=500, detail=f"������ ��� ��������� �������: {str(e)}")

# �������� ��� ������������� ������� � �������� ��������
@app.post("/payment/confirm", response_model=Dict[str, Any])
async def confirm_payment(
    request: Request,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    """������������ �������� ������ � ������� ��������"""
    try:
        # �������� ������ �� �������
        data = await request.json()
        
        # ��������� ������������ ����
        if not data.get("payment_id") or not data.get("user_id"):
            raise HTTPException(status_code=400, detail="����������� ������������ ���������")
        
        payment_id = data["payment_id"]
        user_id = int(data["user_id"])
        
        logger.info(f"������������� ������� {payment_id} ��� ������������ {user_id}")
        
        # ������� �������� �� ������ ��������������� �������
        subscription = await subscription_service.create_subscription(
            user_id=user_id,
            payment_id=payment_id
        )
        
        logger.info(f"�������� ������� �������: {subscription}")
        
        return {
            "success": True,
            "subscription_id": subscription["id"],
            "end_date": subscription["end_date"].isoformat()
        }
    
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"������ ��� ������������� �������: {e}")
        raise HTTPException(status_code=500, detail=f"������ ��� ������������� �������: {str(e)}")

# ���������� �������� ����������� � �������� �� Telegram
@app.post("/payment/webhook", response_model=Dict[str, Any])
async def payment_webhook(
    request: Request,
    subscription_service: SubscriptionService = Depends(get_subscription_service)
):
    """������������ ����������� � �������� �� Telegram"""
    try:
        # �������� ������ �� Telegram Bot API
        data = await request.json()
        logger.info(f"�������� ����������� � �������: {data}")
        
        # ���������, �������� �� ��� ����������� � �������
        if not data.get("update_id") or "pre_checkout_query" not in data and "message" not in data:
            return {"ok": True}
        
        # ������������ pre_checkout_query (��������������� �������� ����� �������)
        if "pre_checkout_query" in data:
            pre_checkout_query = data["pre_checkout_query"]
            query_id = pre_checkout_query["id"]
            payload = pre_checkout_query["invoice_payload"]
            
            logger.info(f"������� pre_checkout_query � payload: {payload}")
            
            # ������ ������������ ������ (� �������� ������� ����� ����� ���� ���. ��������)
            # ���������� ����� �� pre_checkout_query
            bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
            if not bot_token:
                logger.error("����������� ����� ���� ��� ������ �� pre_checkout_query")
                return {"ok": True}
            
            api_url = f"https://api.telegram.org/bot{bot_token}/answerPreCheckoutQuery"
            payload = {
                "pre_checkout_query_id": query_id,
                "ok": True
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.post(api_url, json=payload)
                response_data = response.json()
            
            if not response_data.get("ok"):
                logger.error(f"������ ��� ������ �� pre_checkout_query: {response_data}")
            else:
                logger.info("������� ����������� pre_checkout_query")
            
            return {"ok": True}
        
        # ������������ successful_payment (������� ����������� ������)
        if "message" in data and "successful_payment" in data["message"]:
            message = data["message"]
            payment = message["successful_payment"]
            payload = payment["invoice_payload"]
            user_id = message["from"]["id"]
            
            logger.info(f"������� successful_payment � payload: {payload} �� ������������ {user_id}")
            
            # ������� �������� �� ������ ��������� �������
            try:
                subscription = await subscription_service.create_subscription(
                    user_id=user_id,
                    payment_id=payload
                )
                
                logger.info(f"�������� ������� ������� �� webhook: {subscription}")
                
                # ���������� ����������� ������������ � �������� ��������
                bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
                if bot_token:
                    api_url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
                    message_payload = {
                        "chat_id": user_id,
                        "text": "���� �������� ������� ������������! �� ������ ��������� � ����-����������."
                    }
                    
                    async with httpx.AsyncClient() as client:
                        await client.post(api_url, json=message_payload)
            
            except Exception as e:
                logger.error(f"������ ��� �������� �������� �� webhook: {e}")
        
        return {"ok": True}
    
    except Exception as e:
        logger.error(f"������ ��� ��������� webhook �������: {e}")
        return {"ok": True}  # ������ ���������� �����, ����� �������� ��������� ��������

# ����� �������� ��� ������ ��������� ������� ����� Bot API
# ������������ ���� ��������� /generate-invoice ������
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)

# --- НОВЫЙ ЭНДПОИНТ ДЛЯ ПРЯМОЙ ПРОВЕРКИ ПРЕМИУМА ---\nclass DirectPremiumStatusResponse(BaseModel):\n    is_premium: bool\n    end_date: Optional[str] = None\n    error: Optional[str] = None\n\n@app.get(\"/direct_premium_check\", response_model=DirectPremiumStatusResponse)\nasync def direct_premium_check(request: Request):\n    \"\"\"(Новый) Прямая проверка премиум статуса пользователя в БД\"\"\"\n    user_id_str = request.headers.get(\"x-telegram-user-id\")\n    init_data = request.headers.get(\"x-telegram-init-data\")\n    user_id = None\n\n    # Валидация user_id (можно скопировать логику из /subscription/status)\n    if init_data:\n        # Предполагаем, что функция get_user_id_from_init_data существует и импортирована\n        # from utils.telegram_auth import get_user_id_from_init_data\n        try:\n           validated_user_id = get_user_id_from_init_data(init_data)\n           if validated_user_id:\n               user_id = validated_user_id\n               logger.info(f\"[Direct Check] Пользователь {user_id} идентифицирован через initData\")\n        except NameError: # Если функция не импортирована\            logger.warning(\"[Direct Check] Функция get_user_id_from_init_data не найдена\")\n            pass # Продолжаем без валидации initData, если функция не найдена\n\n    if not user_id and user_id_str:\n        try:\n            user_id = int(user_id_str)\n            logger.info(f\"[Direct Check] Пользователь {user_id} идентифицирован через заголовок\")\n        except ValueError:\n             return DirectPremiumStatusResponse(is_premium=False, error=\"Некорректный user_id в заголовке\")\n\n    if not user_id:\n        return DirectPremiumStatusResponse(is_premium=False, error=\"ID пользователя не определен\")\n\n    logger.info(f\"[Direct Check] Проверка статуса для user_id: {user_id}\")\n\n    # Прямой запрос к Supabase\n    if not supabase:\n        logger.error(\"[Direct Check] Supabase client не инициализирован.\")\n        return DirectPremiumStatusResponse(is_premium=False, error=\"Ошибка подключения к БД\")\n\n    try:\n        # Прямой запрос к таблице user_subscription\n        # Используем PostgREST синтаксис для фильтрации\n        # eq = equals, gt = greater than, is = IS (для TRUE)\n        response = supabase.table(\"user_subscription\") \\\n            .select(\"id, end_date, is_active\") \\\n            .eq(\"user_id\", user_id) \\\n            .eq(\"is_active\", True) \\\
            .gt(\"end_date\", datetime.now(timezone.utc).isoformat()) \\\
            .order(\"end_date\", desc=True) \\\
            .limit(1) \\\
            .execute()\n\n        if response.data and len(response.data) > 0:\n            subscription = response.data[0]\n            end_date_str = subscription.get(\"end_date\")\n            logger.info(f\"[Direct Check] Найдена активная подписка для user_id {user_id}. ID: {subscription.get('id')}, End: {end_date_str}\")\n            return DirectPremiumStatusResponse(is_premium=True, end_date=end_date_str)\n        else:\n            # Проверим, есть ли вообще записи, но неактивные\n            all_subs_resp = supabase.table(\"user_subscription\") \\\n                .select(\"id, end_date, is_active\") \\\n                .eq(\"user_id\", user_id) \\\
                .limit(5) \\\
                .execute()\n            logger.info(f\"[Direct Check] Активная подписка не найдена для user_id {user_id}. Response: {response.data}. Все подписки: {all_subs_resp.data}\")\n            return DirectPremiumStatusResponse(is_premium=False)\n\n    except APIError as api_err:\n        logger.error(f\"[Direct Check] Ошибка API Supabase: {api_err.message}\")\n        return DirectPremiumStatusResponse(is_premium=False, error=f\"Ошибка API: {api_err.message}\")\n    except Exception as e:\n        logger.error(f\"[Direct Check] Непредвиденная ошибка: {e}\", exc_info=True)\n        return DirectPremiumStatusResponse(is_premium=False, error=\"Внутренняя ошибка сервера\")\n\n# --- КОНЕЦ НОВОГО ЭНДПОИНТА ---\n\n# ... остальной код ...
